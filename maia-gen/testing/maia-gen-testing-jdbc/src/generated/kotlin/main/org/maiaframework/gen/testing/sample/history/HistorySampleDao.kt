// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.sample.history

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.sql.PreparedStatement
import java.time.Instant


@Repository
class HistorySampleDao(
    private val fieldConverter: HistorySampleEntityFieldConverter,
    private val historyDao: HistorySampleHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = HistorySampleEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    fun insert(entity: HistorySampleEntity) {

        jdbcOps.update(
            """
            insert into testing.history_sample (
                created_by_id,
                created_timestamp_utc,
                id,
                last_modified_by_id,
                last_modified_timestamp_utc,
                some_int,
                some_string,
                version
            ) values (
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :someString,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdById", entity.createdById)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("lastModifiedById", entity.lastModifiedById)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("someInt", entity.someInt)
                addValue("someString", entity.someString)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<HistorySampleEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.history_sample (
                created_by_id,
                created_timestamp_utc,
                id,
                last_modified_by_id,
                last_modified_timestamp_utc,
                some_int,
                some_string,
                version
            ) values (
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :someString,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdById", entity.createdById)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("lastModifiedById", entity.lastModifiedById)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("someInt", entity.someInt)
                    addValue("someString", entity.someString)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: HistorySampleEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: HistorySampleEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<HistorySampleEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: HistorySampleEntity,
        version: Long,
        changeType: ChangeType
    ): HistorySampleHistoryEntity {

        val id = entity.id
        val createdById = entity.createdById
        val createdTimestampUtc = entity.createdTimestampUtc
        val lastModifiedById = entity.lastModifiedById
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val someInt = entity.someInt
        val someString = entity.someString

        return HistorySampleHistoryEntity(
                changeType,
                createdById,
                createdTimestampUtc,
                id,
                lastModifiedById,
                lastModifiedTimestampUtc,
                someInt,
                someString,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.history_sample",
            SqlParams()
        )

    }


    fun count(filter: HistorySampleEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.history_sample
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): HistorySampleEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    HistorySampleEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                HistorySampleEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): HistorySampleEntity? {

        return jdbcOps.queryForList(
            "select * from testing.history_sample where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.history_sample where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findOneOrNullBySomeString(someString: String): HistorySampleEntity? {

        return jdbcOps.queryForList(
            """
            select * from testing.history_sample
            where some_string = :someString
            """.trimIndent(),
            SqlParams().apply {
            addValue("someString", someString)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    @Throws(EntityNotFoundException::class)
    fun findOneBySomeString(someString: String): HistorySampleEntity {

        return findOneOrNullBySomeString(someString)
            ?: throw EntityNotFoundException("No record with column [some_string = $someString] found in table testing.history_sample.", HistorySampleEntityMeta.TABLE_NAME)

    }


    fun findAllBy(filter: HistorySampleEntityFilter): List<HistorySampleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.history_sample where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: HistorySampleEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from testing.history_sample where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.history_sample;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: HistorySampleEntityFilter, pageable: Pageable): List<HistorySampleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.history_sample where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<HistorySampleEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.history_sample;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun existsBySomeString(someString: String): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.history_sample
            where some_string = :someString
            """.trimIndent(),
            SqlParams().apply {
            addValue("someString", someString)
            }
        )

        return count > 0

    }


    fun existsByCreatedById(createdById: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.history_sample
            where created_by_id = :createdById
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdById", createdById)
            }
        )

        return count > 0

    }


    fun existsByLastModifiedById(lastModifiedById: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.history_sample
            where last_modified_by_id = :lastModifiedById
            """.trimIndent(),
            SqlParams().apply {
            addValue("lastModifiedById", lastModifiedById)
            }
        )

        return count > 0

    }


    fun upsertBySomeString(upsertEntity: HistorySampleEntity): HistorySampleEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into testing.history_sample (
                created_by_id,
                created_timestamp_utc,
                id,
                last_modified_by_id,
                last_modified_timestamp_utc,
                some_int,
                some_string,
                version
            ) values (
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :someString,
                :version
            )
            on conflict (some_string)
            do update set
                last_modified_by_id = :lastModifiedById,
                last_modified_timestamp_utc = :lastModifiedTimestampUtc,
                some_int = :someInt,
                some_string = :someString,
                version = testing.history_sample.version + 1
            returning *;
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdById", upsertEntity.createdById)
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("id", upsertEntity.id)
            addValue("lastModifiedById", upsertEntity.lastModifiedById)
            addValue("lastModifiedTimestampUtc", upsertEntity.lastModifiedTimestampUtc)
            addValue("someInt", upsertEntity.someInt)
            addValue("someString", upsertEntity.someString)
            addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        val changeType = if (persistedEntity!!.id != upsertEntity.id) ChangeType.UPDATE else ChangeType.CREATE
        insertHistory(persistedEntity, persistedEntity.version, changeType)

        return persistedEntity!!

    }


    fun setFields(updaters: List<HistorySampleEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: HistorySampleEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update testing.history_sample set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("version_incremented", "version", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")
        sql.append(" and version = :version")

        sqlParams.addValue("id", updater.id)

        sqlParams.addValue("version", updater.version)
        sqlParams.addValue("version_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(HistorySampleEntityMeta.TABLE_NAME, updater.primaryKey, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.id)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "lastModifiedById" -> sqlParams.addValue("lastModifiedById", field.value as DomainId)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "someInt" -> sqlParams.addValue("someInt", field.value as Int)
            "someString" -> sqlParams.addValue("someString", field.value as String)
        }

    }


    fun deleteByPrimaryKey(id: DomainId): Boolean {

        val existingEntity = findByPrimaryKeyOrNull(id)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from testing.history_sample where id = :id",
            SqlParams().apply {
                addValue("id", id)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeByPrimaryKey(id: DomainId): HistorySampleEntity? {

        val found = findByPrimaryKeyOrNull(id)

        if (found != null) {
            deleteByPrimaryKey(id)
        }

        return found

    }


    fun deleteBySomeString(someString: String): Boolean {

        val existingEntity = findOneOrNullBySomeString(someString)

        if (existingEntity != null) {

            val deletedCount = this.jdbcOps.update(
                "delete from testing.history_sample where id = :id",
                SqlParams().apply {
                    addValue("id", existingEntity.id)
                }
            )

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))

            return deletedCount > 0

        } else {

            return false

        }

    }


}


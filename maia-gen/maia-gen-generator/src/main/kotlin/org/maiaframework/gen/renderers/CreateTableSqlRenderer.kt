package org.maiaframework.gen.renderers

import org.maiaframework.gen.spec.definition.EntityDef
import org.maiaframework.gen.spec.definition.EntityFieldDef
import org.maiaframework.gen.spec.definition.EntityHierarchy
import org.maiaframework.gen.spec.definition.jdbc.TableColumnName
import org.maiaframework.gen.spec.definition.lang.ClassFieldName
import org.maiaframework.gen.spec.definition.lang.FieldType
import org.maiaframework.gen.spec.definition.lang.ForeignKeyFieldType
import org.maiaframework.jdbc.JdbcCompatibleType

class CreateTableSqlRenderer(
    private val entityHierarchies: List<EntityHierarchy>,
    private val renderedFilePath: String
): AbstractSourceFileRenderer() {


    override fun renderedFilePath(): String {

        return renderedFilePath

    }


    override fun renderSource(): String {

        `render header comment`()

        this.entityHierarchies.forEach { `render CREATE TABLE statement for`(it) }

        return sourceCode.toString()

    }


    private fun `render header comment`() {

        appendLine("-- This source was generated by the Maia Framework code generator")
        appendLine("-- Renderer class: $javaClass")

    }


    private fun `render CREATE TABLE statement for`(entityHierarchy: EntityHierarchy) {

        val baseEntityDef = entityHierarchy.entityDef

        blankLine()
        blankLine()

        if (entityHierarchy.hasSubclasses()) {
            appendLine("-- Type Discriminators: ${entityHierarchy.entityDefs.filter { it.typeDiscriminatorOrNull != null }.map { "${it.entityBaseName} -> ${it.typeDiscriminatorOrNull}" }.joinToString(", ")}")
        }

        appendLine("CREATE TABLE ${schemaAndTableNameFor(baseEntityDef)} (")

        val typeDiscriminatorLineOrNull = if (entityHierarchy.hasSubclasses()) {
            "type_discriminator text not null"
        } else {
            null
        }

        val nonDerivedSqlFields: List<SqlFieldDef> = entityHierarchy.allFieldDefsSorted
            .filterNot { it.isDerived.value }
            .groupBy { it.tableColumnName}
            .mapValues { toSqlFieldDef(it, entityHierarchy) }
            .values
            .toList()

        val lines = nonDerivedSqlFields.map { sqlFieldDef ->

            val fieldType = sqlFieldDef.fieldType

            val nullSuffix = if (sqlFieldDef.nullable) "NULL" else "NOT NULL"
            val postgresDataType = FieldTypeRendererHelper.determineSqlDataType(fieldType)
            val sizeConstraint = sqlFieldDef.sizeConstraint
            val foreignKey = if (fieldType is ForeignKeyFieldType) { " REFERENCES ${schemaAndTableNameFor(fieldType.foreignKeyFieldDef.foreignEntityDef)}(id)" } else ""

            "${sqlFieldDef.tableColumnName} $postgresDataType$sizeConstraint $nullSuffix$foreignKey"

        }

        val allLines = listOfNotNull(typeDiscriminatorLineOrNull).plus(lines)
        allLines.forEach { appendLine("    $it,") }

        val primaryKeyFieldCsv = nonDerivedSqlFields.filter { it.isPrimaryKey }.map { it.tableColumnName }.joinToString(", ")
        appendLine("    PRIMARY KEY($primaryKeyFieldCsv)")

        appendLine(");")

        renderIndexes(entityHierarchy)

    }


    private fun toSqlFieldDef(
        entityFieldDefs: Map.Entry<TableColumnName, List<EntityFieldDef>>,
        entityHierarchy: EntityHierarchy
    ): SqlFieldDef {

        val tableColumnName = entityFieldDefs.key
        val fieldTypes = entityFieldDefs.value.map { it.fieldType }.toSet()

        if (fieldTypes.size > 1) {
            throw IllegalStateException("Expecting all fields with database column name of $tableColumnName in entity hierarchy ${entityHierarchy.entityDef.entityBaseName} to have the same type. Found: $fieldTypes")
        }

        val sizeConstraint = maxSizeConstraintFor(entityFieldDefs)

        return SqlFieldDef(
           fieldType = fieldTypes.first(),
           tableColumnName = tableColumnName,
           sizeConstraint = sizeConstraint,
           nullable = entityFieldDefs.value.any { shouldBeNullable(it, entityHierarchy.entityDef) },
           isPrimaryKey = entityFieldDefs.value.any { it.isPrimaryKey.value },
       )

    }


    private fun maxSizeConstraintFor(entityFieldDefs: Map.Entry<TableColumnName, List<EntityFieldDef>>): String {

        val maxSizeConstraint = determineMaxSizeConstraintFor(entityFieldDefs.value)
        return determineSizeConstraintFor(maxSizeConstraint)

    }


    private fun shouldBeNullable(
        entityFieldDef: EntityFieldDef,
        baseEntityDef: EntityDef
    ): Boolean {

        return entityFieldDef.nullable
                || (entityFieldDef.isNotFromBaseEntity(baseEntityDef) && !notNullByFramework(entityFieldDef))

    }


    private fun EntityFieldDef.isNotFromBaseEntity(baseEntityDef: EntityDef): Boolean {
        return entityBaseName != baseEntityDef.entityBaseName
    }


    private fun notNullByFramework(entityFieldDef: EntityFieldDef): Boolean {

        return (entityFieldDef.classFieldName == ClassFieldName.id
                || entityFieldDef.classFieldName == ClassFieldName.createdTimestampUtc
                || entityFieldDef.classFieldName == ClassFieldName.lastModifiedTimestampUtc
                || entityFieldDef.classFieldName == ClassFieldName.version)

    }


    private fun determineMaxSizeConstraintFor(entityFieldDefs: List<EntityFieldDef>): EntityFieldDef? {

        if (entityFieldDefs.any { it.classFieldDef.lengthConstraint == null }) {
            return null
        }

        return entityFieldDefs
            .maxBy { it.classFieldDef.lengthConstraint?.max ?: 0 }

    }


    private fun determineSizeConstraintFor(entityFieldDef: EntityFieldDef?): String {

        if (entityFieldDef == null) {
            return ""
        }

        return when (entityFieldDef.fieldType.jdbcCompatibleType) {
            JdbcCompatibleType.varchar -> "(${maxLengthOf(entityFieldDef)})"
            else -> ""
        }

    }


    private fun maxLengthOf(entityFieldDef: EntityFieldDef): Long {

        return entityFieldDef.classFieldDef.lengthConstraint?.max
            ?: throw IllegalArgumentException("Expecting entity field '${entityFieldDef.classFieldName}' on entity '${entityFieldDef.entityBaseName}' to have a max length constraint.")

    }


    private fun renderIndexes(entityHierarchy: EntityHierarchy) {

        val baseEntityDef = entityHierarchy.entityDef

        entityHierarchy.entityDefs
            .reversed()
            .map { it.databaseIndexDefs }
            .flatten()
            .distinctBy { databaseIndexDef -> databaseIndexDef.indexDef.indexFieldDefs.map { it.databaseColumnName } }
            .forEach { databaseIndexDef ->

                val unique = if (databaseIndexDef.isUnique) " UNIQUE" else ""
                val indexName = databaseIndexDef.indexDef.indexName
                val typeDiscriminatorField = if (entityHierarchy.hasSubclasses()) listOf(TableColumnName("type_discriminator")) else emptyList()
                val fields = databaseIndexDef.indexDef.indexFieldDefs.map { it.databaseColumnName }.plus(typeDiscriminatorField).joinToString(", ")

                appendLine("CREATE$unique INDEX $indexName ON ${schemaAndTableNameFor(baseEntityDef)}($fields);")

            }

    }


    private fun schemaAndTableNameFor(entityDef: EntityDef) = "${entityDef.schemaName}.${entityDef.tableName.rawTableName}"


    private data class SqlFieldDef(
        val fieldType: FieldType,
        val tableColumnName: TableColumnName,
        val sizeConstraint: String,
        val nullable: Boolean,
        val isPrimaryKey: Boolean,
    )


}

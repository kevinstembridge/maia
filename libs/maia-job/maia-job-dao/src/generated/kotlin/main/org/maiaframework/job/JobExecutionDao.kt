// This source was generated by the Mahana code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.job

import com.fasterxml.jackson.databind.ObjectMapper
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndId
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.SqlParams
import org.maiaframework.json.JsonFacade
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.time.Instant


@Repository
class JobExecutionDao(
    private val fieldConverter: JobExecutionEntityFieldConverter,
    private val jdbcOps: JdbcOps,
    private val jsonFacade: JsonFacade,
    private val objectMapper: ObjectMapper
) {


    private val entityRowMapper = JobExecutionEntityRowMapper(objectMapper)


    fun insert(entity: JobExecutionEntity) {

        jdbcOps.update(
            """
            insert into jobs.job_execution (
                completion_status,
                c_ts,
                end_timestamp_utc,
                error_message,
                id,
                invoked_by,
                job_name,
                lm_ts,
                metrics,
                stack_trace,
                start_timestamp_utc
            ) values (
                :completionStatus,
                :createdTimestampUtc,
                :endTimestampUtc,
                :errorMessage,
                :id,
                :invokedBy,
                :jobName,
                :lastModifiedTimestampUtc,
                :metrics,
                :stackTrace,
                :startTimestampUtc
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("completionStatus", entity.completionStatus)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("endTimestampUtc", entity.endTimestampUtc)
                addValue("errorMessage", entity.errorMessage)
                addValue("id", entity.id)
                addValue("invokedBy", entity.invokedBy)
                addValue("jobName", entity.jobName)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addJsonValue("metrics", objectMapper.writeValueAsString(entity.metrics))
                addValue("stackTrace", entity.stackTrace)
                addValue("startTimestampUtc", entity.startTimestampUtc)
            }
        )

    }


    fun bulkInsert(entities: List<JobExecutionEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into jobs.job_execution (
                completion_status,
                c_ts,
                end_timestamp_utc,
                error_message,
                id,
                invoked_by,
                job_name,
                lm_ts,
                metrics,
                stack_trace,
                start_timestamp_utc
            ) values (
                :completionStatus,
                :createdTimestampUtc,
                :endTimestampUtc,
                :errorMessage,
                :id,
                :invokedBy,
                :jobName,
                :lastModifiedTimestampUtc,
                :metrics,
                :stackTrace,
                :startTimestampUtc
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("completionStatus", entity.completionStatus)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("endTimestampUtc", entity.endTimestampUtc)
                    addValue("errorMessage", entity.errorMessage)
                    addValue("id", entity.id)
                    addValue("invokedBy", entity.invokedBy)
                    addValue("jobName", entity.jobName)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addJsonValue("metrics", objectMapper.writeValueAsString(entity.metrics))
                    addValue("stackTrace", entity.stackTrace)
                    addValue("startTimestampUtc", entity.startTimestampUtc)
                }
            }
        )

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from jobs.job_execution",
            SqlParams()
        )

    }


    fun count(filter: JobExecutionEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from jobs.job_execution
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findById(id: DomainId): JobExecutionEntity {

        return findByIdOrNull(id)
            ?: throw EntityNotFoundException(EntityClassAndId(JobExecutionEntity::class.java, id), JobExecutionEntityMeta.TABLE_NAME)

    }


    fun findByIdOrNull(id: DomainId): JobExecutionEntity? {

        return jdbcOps.queryForList(
            "select * from jobs.job_execution where id = :id",
            SqlParams().apply {
                addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun findByJobName(jobName: JobName): List<JobExecutionEntity> {

        return jdbcOps.queryForList(
            """
            select * from jobs.job_execution
            where job_name = :jobName
            """.trimIndent(),
            SqlParams().apply {
                addValue("jobName", jobName)
            },
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: JobExecutionEntityFilter): List<JobExecutionEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from jobs.job_execution where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllIdsAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from jobs.job_execution;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: JobExecutionEntityFilter, pageable: Pageable): List<JobExecutionEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from jobs.job_execution where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<JobExecutionEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from jobs.job_execution;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun setFields(updaters: List<JobExecutionEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: JobExecutionEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update jobs.job_execution set ")

        val fieldClauses = updater.fields
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")

        sqlParams.addValue("id", updater.id)

        return this.jdbcOps.update(sql.toString(), sqlParams)

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "completionStatus" -> sqlParams.addValue("completionStatus", field.value as JobCompletionStatus?)
            "endTimestampUtc" -> sqlParams.addValue("endTimestampUtc", field.value as Instant?)
            "errorMessage" -> sqlParams.addValue("errorMessage", field.value as String?)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "metrics" -> sqlParams.addJsonValue("metrics", this.objectMapper.writeValueAsString(field.value as Map<String, Any>))
            "stackTrace" -> sqlParams.addValue("stackTrace", field.value as String?)
        }

    }


}



TODO * Open source it
    TODO * Figure out how to plug in additional capabilities. e.g. Hazelcast, ElasticSearch
    TODO * Consider Apache Ignite
    TODO * Fix tailwindcss styling
    TODO * Gradle plugin
        TODO * Publish to Gradle plugins site
    TODO * Remove or don't port Mongo support => Rename modules such as testing-jdbc
        TODO * Remove DatabaseType?
    TODO * Documentation
        TODO * Public docs via Github Pages
    TODO * Publish to Maven Central


TODO * Introduce Optimistic Locking
    TODO * Modify InlineEditableFieldJsRenderer to take version into account


TODO * Allow finders to be specified
    ** DONE For unique fields, automatically generate a finder
    e.g. IssueInfoDao.findLatest, findByBuildNumber, findByBuildNumberRange, deleteByIssueNumber
    ** DONE specify indexes, generate finders for them
    ** TODO specify finders by any combination of fields

TODO * Add *Stream methods for list fields

TODO * Render a TestBuilder per entity
    OR * Render copy methods on entities and value objects

TODO * Validation rules:
    ** c-ts is a reserved collectionFieldName
    ** lm-ts is a reserved collectionFieldName
    ** v is a reserved collectionFieldName
    ** TYP is a reserved collectionFieldName
    ** a field name must not be duplicated within a hierarchy
    ** Abstract classes must not have a TypeDiscriminator
    ** A TTL index can only be specified on an Instant field

TODO * Generators should only be invoked if they are specified in the spec file.
    * This makes the framework more customisable for users who don't want the standard components generated. Or they want to plug in their own renderers.

TODO * Allow javadoc to be specified for each class and field.


TECH DEBT:
TODO * AbstractJavaRenderer.addConstructorArg takes a ClassField argument. In order to render a constructor properly it needs to know if the field is inherited or not. But at the point an immutable ClassField is constructed it doesn't know if it is inherited.

Field Writers Issue:
We need to use FieldWriters when constructing query filters. The existing FieldWriters take a Document and populate it.
But the structure of the Document required in a filter is different than the structure the existing FieldWriters create.
    e.g. {someField: {"$gt", 100}}
If the FieldWriters are changed so that they solely convert an input value to an output value then the knowledge of the structure can be moved into the calling class.
But this would also mean that we lose the ability for the converter to change the output type. Not true. The calling class just puts the output value into a Document. It doesn't care about its type.
We would lose the ability for the FieldWriter to split a value into multiple fields.
How would a Filter work if the converter wanted to split into multiple fields?

! Modify FieldWriters to be converters that just convert a value and don't populate the Document.


MapFieldReader

Inject a MapFieldReader instance based on a @Qualifier. The qualifier should be unique based on dataClassKey and fieldName.
In DaoRenderer
    If field has an explicit FieldReaderFqcn,
        use it.
    else use a MapFieldReader instance that is injected with an appropriate keyMapper and valueMapper
        if an explicit keyMapper or valueMapper is declared
            use it
        else
            use an implicit mapper

The above implies that the FieldDef for a map field must know the classFieldName used for the reader.

DONE FieldDef.getFieldReaderFqcn() must be changed to return a ParameterizedType.

TODO figure out how to use an InstantFieldConverter in the InstantListFieldReader.
    This means we could do away with the *ListFieldReader classes and use the converters in Lists, Maps and Sets.
    This also means that a spec author could declare a default converter for a given FieldType and that would be
    used for single fields as well as collections containing that fieldType.

    To automatically use a default fieldType converter in a List field...
        - create a ListFieldReader class that takes a converter as an argument.
        - The entityFieldDef.getFieldReaderFqcn will have to return ListFieldReader<T>
            ~> modify fieldReaderFqcn to return a ParameterizedType
        - Must be able to find an implicit FieldConverter for a given FieldType

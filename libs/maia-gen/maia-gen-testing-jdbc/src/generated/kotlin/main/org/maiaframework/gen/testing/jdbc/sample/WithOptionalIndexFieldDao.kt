// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.jdbc.sample

import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.gen.sample.types.SomeStringType
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository


@Repository
class WithOptionalIndexFieldDao(
    private val fieldConverter: WithOptionalIndexFieldEntityFieldConverter,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = WithOptionalIndexFieldEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    fun insert(entity: WithOptionalIndexFieldEntity) {

        jdbcOps.update(
            """
            insert into testing.with_optional_index_field (
                c_ts,
                id,
                some_optional_string1,
                some_optional_string2,
                some_string
            ) values (
                :createdTimestampUtc,
                :id,
                :someOptionalString1,
                :someOptionalString2,
                :someString
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("someOptionalString1", entity.someOptionalString1)
                addValue("someOptionalString2", entity.someOptionalString2)
                addValue("someString", entity.someString)
            }
        )

    }


    fun bulkInsert(entities: List<WithOptionalIndexFieldEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.with_optional_index_field (
                c_ts,
                id,
                some_optional_string1,
                some_optional_string2,
                some_string
            ) values (
                :createdTimestampUtc,
                :id,
                :someOptionalString1,
                :someOptionalString2,
                :someString
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("someOptionalString1", entity.someOptionalString1)
                    addValue("someOptionalString2", entity.someOptionalString2)
                    addValue("someString", entity.someString)
                }
            }
        )

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.with_optional_index_field",
            SqlParams()
        )

    }


    fun count(filter: WithOptionalIndexFieldEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.with_optional_index_field
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): WithOptionalIndexFieldEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    WithOptionalIndexFieldEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                WithOptionalIndexFieldEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): WithOptionalIndexFieldEntity? {

        return jdbcOps.queryForList(
            "select * from testing.with_optional_index_field where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.with_optional_index_field where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findBySomeOptionalString1(someOptionalString1: SomeStringType): List<WithOptionalIndexFieldEntity> {

        return jdbcOps.queryForList(
            """
            select * from testing.with_optional_index_field
            where some_optional_string1 = :someOptionalString1
            """.trimIndent(),
            SqlParams().apply {
            addValue("someOptionalString1", someOptionalString1)
            },
            this.entityRowMapper
        )

    }


    fun findBySomeOptionalString2AndSomeString(
        someOptionalString2: SomeStringType,
        someString: SomeStringType
    ): List<WithOptionalIndexFieldEntity> {

        return jdbcOps.queryForList(
            """
            select * from testing.with_optional_index_field
            where some_optional_string2 = :someOptionalString2
            and some_string = :someString
            """.trimIndent(),
            SqlParams().apply {
            addValue("someOptionalString2", someOptionalString2)
            addValue("someString", someString)
            },
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: WithOptionalIndexFieldEntityFilter): List<WithOptionalIndexFieldEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.with_optional_index_field where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: WithOptionalIndexFieldEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from testing.with_optional_index_field where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.with_optional_index_field;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: WithOptionalIndexFieldEntityFilter, pageable: Pageable): List<WithOptionalIndexFieldEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.with_optional_index_field where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<WithOptionalIndexFieldEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.with_optional_index_field;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


}


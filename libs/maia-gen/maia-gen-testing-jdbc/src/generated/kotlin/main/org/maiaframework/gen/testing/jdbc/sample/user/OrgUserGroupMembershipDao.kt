// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.jdbc.sample.user

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.sql.PreparedStatement


@Repository
class OrgUserGroupMembershipDao(
    private val fieldConverter: OrgUserGroupMembershipEntityFieldConverter,
    private val historyDao: OrgUserGroupMembershipHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = OrgUserGroupMembershipEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    private val idRowMapper = MaiaRowMapper { rs -> rs.readDomainId("id") }


    fun insert(entity: OrgUserGroupMembershipEntity) {

        jdbcOps.update(
            """
            insert into testing.org_user_group_membership (
                c_ts,
                id,
                org_user_group_id,
                user_id,
                v
            ) values (
                :createdTimestampUtc,
                :id,
                :orgUserGroupId,
                :userId,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("orgUserGroupId", entity.orgUserGroupId)
                addValue("userId", entity.userId)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<OrgUserGroupMembershipEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.org_user_group_membership (
                c_ts,
                id,
                org_user_group_id,
                user_id,
                v
            ) values (
                :createdTimestampUtc,
                :id,
                :orgUserGroupId,
                :userId,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("orgUserGroupId", entity.orgUserGroupId)
                    addValue("userId", entity.userId)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: OrgUserGroupMembershipEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: OrgUserGroupMembershipEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<OrgUserGroupMembershipEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: OrgUserGroupMembershipEntity,
        version: Long,
        changeType: ChangeType
    ): OrgUserGroupMembershipHistoryEntity {

        val id = entity.id
        val createdTimestampUtc = entity.createdTimestampUtc
        val orgUserGroupId = entity.orgUserGroupId
        val userId = entity.userId

        return OrgUserGroupMembershipHistoryEntity(
                changeType,
                createdTimestampUtc,
                id,
                orgUserGroupId,
                userId,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.org_user_group_membership",
            SqlParams()
        )

    }


    fun count(filter: OrgUserGroupMembershipEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.org_user_group_membership
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): OrgUserGroupMembershipEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    OrgUserGroupMembershipEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                OrgUserGroupMembershipEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): OrgUserGroupMembershipEntity? {

        return jdbcOps.queryForList(
            "select * from testing.org_user_group_membership where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.org_user_group_membership where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findOneOrNullByOrgUserGroupIdAndUserId(
        orgUserGroupId: DomainId,
        userId: DomainId
    ): OrgUserGroupMembershipEntity? {

        return jdbcOps.queryForList(
            """
            select * from testing.org_user_group_membership
            where org_user_group_id = :orgUserGroupId
            and user_id = :userId
            """.trimIndent(),
            SqlParams().apply {
            addValue("orgUserGroupId", orgUserGroupId)
            addValue("userId", userId)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    @Throws(EntityNotFoundException::class)
    fun findOneByOrgUserGroupIdAndUserId(
        orgUserGroupId: DomainId,
        userId: DomainId
    ): OrgUserGroupMembershipEntity {

        return findOneOrNullByOrgUserGroupIdAndUserId(orgUserGroupId, userId)
            ?: throw EntityNotFoundException("No record with column [org_user_group_id = $orgUserGroupId, user_id = $userId] found in table testing.org_user_group_membership.", OrgUserGroupMembershipEntityMeta.TABLE_NAME)

    }


    fun findByUserId(userId: DomainId): List<OrgUserGroupMembershipEntity> {

        return jdbcOps.queryForList(
            """
            select * from testing.org_user_group_membership
            where user_id = :userId
            """.trimIndent(),
            SqlParams().apply {
            addValue("userId", userId)
            },
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: OrgUserGroupMembershipEntityFilter): List<OrgUserGroupMembershipEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.org_user_group_membership where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: OrgUserGroupMembershipEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from testing.org_user_group_membership where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.org_user_group_membership;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: OrgUserGroupMembershipEntityFilter, pageable: Pageable): List<OrgUserGroupMembershipEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.org_user_group_membership where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<OrgUserGroupMembershipEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.org_user_group_membership;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun existsByOrgUserGroupIdAndUserId(
        orgUserGroupId: DomainId,
        userId: DomainId
    ): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.org_user_group_membership
            where org_user_group_id = :orgUserGroupId
            and user_id = :userId
            """.trimIndent(),
            SqlParams().apply {
            addValue("orgUserGroupId", orgUserGroupId)
            addValue("userId", userId)
            }
        )

        return count > 0

    }


    fun upsertByOrgUserGroupIdAndUserId(upsertEntity: OrgUserGroupMembershipEntity): OrgUserGroupMembershipEntityPk {

        return jdbcOps.execute(
            """
            with input_rows(
                c_ts,
                id,
                org_user_group_id,
                user_id,
                v
            ) as (
                values (
                    cast(:createdTimestampUtc as timestamp(3) with time zone),
                    cast(:id as uuid),
                    cast(:orgUserGroupId as uuid),
                    cast(:userId as uuid),
                    cast(:version as bigint)
                )
            )
            , ins as (
                insert into testing.org_user_group_membership (
                    c_ts,
                    id,
                    org_user_group_id,
                    user_id,
                    v
                )
                select * from input_rows
                on conflict (org_user_group_id, user_id) do nothing
                returning id
            )
            select 'i' as source, id
            from ins
            union all
            select 's' as source, c.id
            from input_rows
            join testing.org_user_group_membership c using (org_user_group_id, user_id);
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("id", upsertEntity.id)
            addValue("orgUserGroupId", upsertEntity.orgUserGroupId)
            addValue("userId", upsertEntity.userId)
            addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                primaryKeyRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )!!

    }


}


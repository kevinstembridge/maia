// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.jdbc.sample.composite_pk

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.sql.PreparedStatement


@Repository
class CompositePrimaryKeyDao(
    private val fieldConverter: CompositePrimaryKeyEntityFieldConverter,
    private val historyDao: CompositePrimaryKeyHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = CompositePrimaryKeyEntityRowMapper()


    private val primaryKeyRowMapper = CompositePrimaryKeyEntityPkRowMapper()


    fun insert(entity: CompositePrimaryKeyEntity) {

        jdbcOps.update(
            """
            insert into testing.composite_primary_key (
                c_ts,
                some_int,
                some_modifiable_string,
                some_string,
                v
            ) values (
                :createdTimestampUtc,
                :someInt,
                :someModifiableString,
                :someString,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("someInt", entity.someInt)
                addValue("someModifiableString", entity.someModifiableString)
                addValue("someString", entity.someString)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<CompositePrimaryKeyEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.composite_primary_key (
                c_ts,
                some_int,
                some_modifiable_string,
                some_string,
                v
            ) values (
                :createdTimestampUtc,
                :someInt,
                :someModifiableString,
                :someString,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("someInt", entity.someInt)
                    addValue("someModifiableString", entity.someModifiableString)
                    addValue("someString", entity.someString)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: CompositePrimaryKeyEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: CompositePrimaryKeyEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<CompositePrimaryKeyEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: CompositePrimaryKeyEntity,
        version: Long,
        changeType: ChangeType
    ): CompositePrimaryKeyHistoryEntity {

        val createdTimestampUtc = entity.createdTimestampUtc
        val someInt = entity.someInt
        val someModifiableString = entity.someModifiableString
        val someString = entity.someString

        return CompositePrimaryKeyHistoryEntity(
                changeType,
                createdTimestampUtc,
                someInt,
                someModifiableString,
                someString,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.composite_primary_key",
            SqlParams()
        )

    }


    fun count(filter: CompositePrimaryKeyEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.composite_primary_key
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(someString: String, someInt: Int): CompositePrimaryKeyEntity {

        return findByPrimaryKeyOrNull(someString, someInt)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    CompositePrimaryKeyEntity::class.java,
                    mapOf(
                        "someString" to someString,
                        "someInt" to someInt,
                    )
                ),
                CompositePrimaryKeyEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(someString: String, someInt: Int): CompositePrimaryKeyEntity? {

        return jdbcOps.queryForList(
            "select * from testing.composite_primary_key where some_string = :someString and some_int = :someInt",
            SqlParams().apply {
            addValue("someString", someString)
            addValue("someInt", someInt)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(someString: String, someInt: Int): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.composite_primary_key where some_string = :someString and some_int = :someInt",
            SqlParams().apply {
                addValue("someString", someString)
                addValue("someInt", someInt)
           }
        )
       
        return count > 0
       
    }

    fun findAllBy(filter: CompositePrimaryKeyEntityFilter): List<CompositePrimaryKeyEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.composite_primary_key where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: CompositePrimaryKeyEntityFilter): Sequence<CompositePrimaryKeyEntityPk> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select some_string, some_int from testing.composite_primary_key where $whereClause",
            sqlParams,
            this.primaryKeyRowMapper
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<CompositePrimaryKeyEntityPk> {

        return this.jdbcOps.queryForSequence(
            "select some_string, some_int from testing.composite_primary_key;",
            SqlParams(),
            this.primaryKeyRowMapper
        )

    }


    fun findAllBy(filter: CompositePrimaryKeyEntityFilter, pageable: Pageable): List<CompositePrimaryKeyEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.composite_primary_key where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<CompositePrimaryKeyEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.composite_primary_key;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun upsertBySomeStringAndSomeInt(upsertEntity: CompositePrimaryKeyEntity): CompositePrimaryKeyEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into testing.composite_primary_key (
                c_ts,
                some_int,
                some_modifiable_string,
                some_string,
                v
            ) values (
                :createdTimestampUtc,
                :someInt,
                :someModifiableString,
                :someString,
                :version
            )
            on conflict (some_string, some_int)
            do update set
                some_modifiable_string = :someModifiableString,
                v = testing.composite_primary_key.v + 1
            returning *;
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("someInt", upsertEntity.someInt)
            addValue("someModifiableString", upsertEntity.someModifiableString)
            addValue("someString", upsertEntity.someString)
            addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        val changeType = if (persistedEntity!!.primaryKey != upsertEntity.primaryKey) ChangeType.UPDATE else ChangeType.CREATE
        insertHistory(persistedEntity, persistedEntity.version, changeType)

        return persistedEntity!!

    }


    fun setFields(updaters: List<CompositePrimaryKeyEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: CompositePrimaryKeyEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update testing.composite_primary_key set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("v_incremented", "v", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where some_string = :someString and some_int = :someInt")
        sql.append(" and v = :v")

        sqlParams.addValue("someString", updater.someString)
        sqlParams.addValue("someInt", updater.someInt)
        sqlParams.addValue("v", updater.version)
        sqlParams.addValue("v_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(CompositePrimaryKeyEntityMeta.TABLE_NAME, updater.primaryKey, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.someString, updater.someInt)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "someModifiableString" -> sqlParams.addValue("someModifiableString", field.value as String)
        }

    }


    fun deleteByPrimaryKey(someString: String, someInt: Int): Boolean {

        val existingEntity = findByPrimaryKeyOrNull(someString, someInt)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from testing.composite_primary_key where some_string = :someString and some_int = :someInt",
            SqlParams().apply {
                addValue("someString", someString)
                addValue("someInt", someInt)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeByPrimaryKey(someString: String, someInt: Int): CompositePrimaryKeyEntity? {

        val found = findByPrimaryKeyOrNull(someString, someInt)

        if (found != null) {
            deleteByPrimaryKey(someString, someInt)
        }

        return found

    }


    fun deleteAll() {
        this.jdbcOps.update("delete from testing.composite_primary_key")
    }


}


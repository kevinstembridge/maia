// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.jdbc.sample.suuper

import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.sql.PreparedStatement
import java.time.Instant


@Repository
class SubTwoDao(
    private val fieldConverter: SubTwoEntityFieldConverter,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = SubTwoEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    fun insert(entity: SubTwoEntity) {

        jdbcOps.update(
            """
            insert into testing.super (
                type_discriminator,
                created_by_id,
                c_ts,
                id,
                lm_by_id,
                lm_ts,
                some_int,
                some_unique_string
            ) values (
                'SUB2',
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :someUniqueString
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdById", entity.createdById)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("lastModifiedById", entity.lastModifiedById)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("someInt", entity.someInt)
                addValue("someUniqueString", entity.someUniqueString)
            }
        )

    }


    fun bulkInsert(entities: List<SubTwoEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.super (
                type_discriminator,
                created_by_id,
                c_ts,
                id,
                lm_by_id,
                lm_ts,
                some_int,
                some_unique_string
            ) values (
                'SUB2',
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :someUniqueString
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdById", entity.createdById)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("lastModifiedById", entity.lastModifiedById)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("someInt", entity.someInt)
                    addValue("someUniqueString", entity.someUniqueString)
                }
            }
        )

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.super",
            SqlParams()
        )

    }


    fun count(filter: SubTwoEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.super
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): SubTwoEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    SubTwoEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                SubTwoEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): SubTwoEntity? {

        return jdbcOps.queryForList(
            "select * from testing.super where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.super where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findOneOrNullBySomeUniqueString(someUniqueString: String): SubTwoEntity? {

        return jdbcOps.queryForList(
            """
            select * from testing.super
            where some_unique_string = :someUniqueString
            and type_discriminator = 'SUB2'
            """.trimIndent(),
            SqlParams().apply {
            addValue("someUniqueString", someUniqueString)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    @Throws(EntityNotFoundException::class)
    fun findOneBySomeUniqueString(someUniqueString: String): SubTwoEntity {

        return findOneOrNullBySomeUniqueString(someUniqueString)
            ?: throw EntityNotFoundException("No record with column [some_unique_string = $someUniqueString] found in table testing.super.", SubTwoEntityMeta.TABLE_NAME)

    }


    fun findAllBy(filter: SubTwoEntityFilter): List<SubTwoEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.super where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: SubTwoEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from testing.super where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.super;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: SubTwoEntityFilter, pageable: Pageable): List<SubTwoEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.super where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<SubTwoEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.super;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun existsBySomeUniqueString(someUniqueString: String): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.super
            where some_unique_string = :someUniqueString
            """.trimIndent(),
            SqlParams().apply {
            addValue("someUniqueString", someUniqueString)
            }
        )

        return count > 0

    }


    fun existsByCreatedById(createdById: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.super
            where created_by_id = :createdById
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdById", createdById)
            }
        )

        return count > 0

    }


    fun existsByLastModifiedById(lastModifiedById: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.super
            where lm_by_id = :lastModifiedById
            """.trimIndent(),
            SqlParams().apply {
            addValue("lastModifiedById", lastModifiedById)
            }
        )

        return count > 0

    }


    fun upsertBySomeUniqueString(upsertEntity: SubTwoEntity): SubTwoEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into testing.super (
                created_by_id,
                c_ts,
                id,
                lm_by_id,
                lm_ts,
                some_int,
                some_unique_string
            ) values (
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :someUniqueString
            )
            on conflict (some_unique_string)
            do update set
                lm_by_id = :lastModifiedById,
                lm_ts = :lastModifiedTimestampUtc,
                some_int = :someInt,
                some_unique_string = :someUniqueString
            returning *;
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdById", upsertEntity.createdById)
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("id", upsertEntity.id)
            addValue("lastModifiedById", upsertEntity.lastModifiedById)
            addValue("lastModifiedTimestampUtc", upsertEntity.lastModifiedTimestampUtc)
            addValue("someInt", upsertEntity.someInt)
            addValue("someUniqueString", upsertEntity.someUniqueString)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        return persistedEntity!!

    }


    fun setFields(updaters: List<SubTwoEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: SubTwoEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update testing.super set ")

        val fieldClauses = updater.fields
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")

        sqlParams.addValue("id", updater.id)

        return this.jdbcOps.update(sql.toString(), sqlParams)

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "lastModifiedById" -> sqlParams.addValue("lastModifiedById", field.value as DomainId)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "someInt" -> sqlParams.addValue("someInt", field.value as Int)
            "someUniqueString" -> sqlParams.addValue("someUniqueString", field.value as String)
        }

    }


    fun deleteByPrimaryKey(id: DomainId): Boolean {

        val existingEntity = findByPrimaryKeyOrNull(id)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from testing.super where id = :id",
            SqlParams().apply {
                addValue("id", id)
            }
        )

        return deletedCount > 0

    }


    fun removeByPrimaryKey(id: DomainId): SubTwoEntity? {

        val found = findByPrimaryKeyOrNull(id)

        if (found != null) {
            deleteByPrimaryKey(id)
        }

        return found

    }


    fun deleteAll() {
        this.jdbcOps.update("delete from testing.super")
    }


    fun deleteBySomeUniqueString(someUniqueString: String): Boolean {

        val existingEntity = findOneOrNullBySomeUniqueString(someUniqueString)

        if (existingEntity != null) {

            val deletedCount = this.jdbcOps.update(
                "delete from testing.super where id = :id",
                SqlParams().apply {
                    addValue("id", existingEntity.id)
                }
            )

            return deletedCount > 0

        } else {

            return false

        }

    }


}


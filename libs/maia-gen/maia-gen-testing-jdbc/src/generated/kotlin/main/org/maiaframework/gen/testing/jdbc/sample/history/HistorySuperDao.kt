// This source was generated by the Mahana code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.jdbc.sample.history

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndId
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.time.Instant


@Repository
class HistorySuperDao(
    private val fieldConverter: HistorySuperEntityFieldConverter,
    private val historyDao: HistorySuperHistoryDao,
    private val historySubOneHistoryDao: HistorySubOneHistoryDao,
    private val historySubTwoHistoryDao: HistorySubTwoHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = HistorySuperEntityRowMapper()


    fun insert(entity: HistorySuperEntity) {

        when (entity) {
            is HistorySubOneEntity -> insertHistorySubOneEntity(entity)
            is HistorySubTwoEntity -> insertHistorySubTwoEntity(entity)
        }

    }


    private fun insertHistorySubOneEntity(entity: HistorySubOneEntity) {

        jdbcOps.update(
            """
            insert into testing.history_super (
                type_discriminator,
                created_by_id,
                c_ts,
                id,
                lm_by_id,
                lm_ts,
                some_string,
                v
            ) values (
                :typeDiscriminator,
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someString,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", HistorySubOneEntityMeta.TYPE_DISCRIMINATOR)
                addValue("createdById", entity.createdById)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("lastModifiedById", entity.lastModifiedById)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("someString", entity.someString)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    private fun insertHistorySubTwoEntity(entity: HistorySubTwoEntity) {

        jdbcOps.update(
            """
            insert into testing.history_super (
                type_discriminator,
                created_by_id,
                c_ts,
                id,
                lm_by_id,
                lm_ts,
                some_int,
                v
            ) values (
                :typeDiscriminator,
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :someInt,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", HistorySubTwoEntityMeta.TYPE_DISCRIMINATOR)
                addValue("createdById", entity.createdById)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("lastModifiedById", entity.lastModifiedById)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("someInt", entity.someInt)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<HistorySuperEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.history_super (
                created_by_id,
                c_ts,
                id,
                lm_by_id,
                lm_ts,
                v
            ) values (
                :createdById,
                :createdTimestampUtc,
                :id,
                :lastModifiedById,
                :lastModifiedTimestampUtc,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdById", entity.createdById)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("lastModifiedById", entity.lastModifiedById)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: HistorySubOneEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: HistorySubOneEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun insertHistory(entity: HistorySubTwoEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: HistorySubTwoEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<HistorySuperEntity>, changeType: ChangeType) {

        val entitiesByType: Map<String, List<HistorySuperEntity>> = entities.groupBy { entity ->
                when (entity) {
                    is HistorySubOneEntity -> "SUB1"
                    is HistorySubTwoEntity -> "SUB2"
                    else -> throw RuntimeException("Not going to happen (tm)")
                }
        }

        val entitiesSUB1: List<HistorySubOneEntity> = entitiesByType["SUB1"] as? List<HistorySubOneEntity> ?: emptyList()
        val historySubOneHistoryEntityList = entitiesSUB1.map { history(it, it.version + 1, changeType) }
        this.historySubOneHistoryDao.bulkInsert(historySubOneHistoryEntityList)

        val entitiesSUB2: List<HistorySubTwoEntity> = entitiesByType["SUB2"] as? List<HistorySubTwoEntity> ?: emptyList()
        val historySubTwoHistoryEntityList = entitiesSUB2.map { history(it, it.version + 1, changeType) }
        this.historySubTwoHistoryDao.bulkInsert(historySubTwoHistoryEntityList)

    }


    private fun history(
        entity: HistorySubOneEntity,
        version: Long,
        changeType: ChangeType
    ): HistorySubOneHistoryEntity {

        val id = entity.id
        val createdById = entity.createdById
        val createdTimestampUtc = entity.createdTimestampUtc
        val lastModifiedById = entity.lastModifiedById
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val someString = entity.someString

        return HistorySubOneHistoryEntity(
                changeType,
                createdById,
                createdTimestampUtc,
                id,
                lastModifiedById,
                lastModifiedTimestampUtc,
                someString,
                version)

    }


    private fun history(
        entity: HistorySubTwoEntity,
        version: Long,
        changeType: ChangeType
    ): HistorySubTwoHistoryEntity {

        val id = entity.id
        val createdById = entity.createdById
        val createdTimestampUtc = entity.createdTimestampUtc
        val lastModifiedById = entity.lastModifiedById
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val someInt = entity.someInt

        return HistorySubTwoHistoryEntity(
                changeType,
                createdById,
                createdTimestampUtc,
                id,
                lastModifiedById,
                lastModifiedTimestampUtc,
                someInt,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.history_super",
            SqlParams()
        )

    }


    fun count(filter: HistorySuperEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.history_super
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findById(id: DomainId): HistorySuperEntity {

        return findByIdOrNull(id)
            ?: throw EntityNotFoundException(EntityClassAndId(HistorySuperEntity::class.java, id), HistorySuperEntityMeta.TABLE_NAME)

    }


    fun findByIdOrNull(id: DomainId): HistorySuperEntity? {

        return jdbcOps.queryForList(
            "select * from testing.history_super where id = :id",
            SqlParams().apply {
                addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun findAllBy(filter: HistorySuperEntityFilter): List<HistorySuperEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.history_super where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllIdsAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.history_super;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: HistorySuperEntityFilter, pageable: Pageable): List<HistorySuperEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.history_super where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<HistorySuperEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.history_super;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun existsByCreatedById(createdById: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.history_super
            where created_by_id = :createdById
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdById", createdById)
            }
        )

        return count > 0

    }


    fun existsByLastModifiedById(lastModifiedById: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.history_super
            where lm_by_id = :lastModifiedById
            """.trimIndent(),
            SqlParams().apply {
                addValue("lastModifiedById", lastModifiedById)
            }
        )

        return count > 0

    }


    fun setFields(updaters: List<HistorySuperEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: HistorySuperEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update testing.history_super set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("v_incremented", "v", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")
        sql.append(" and v = :v")

        sqlParams.addValue("id", updater.id)
        sqlParams.addValue("v", updater.version)
        sqlParams.addValue("v_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(HistorySuperEntityMeta.TABLE_NAME, updater.id, updater.version)

        } else {

            val updatedEntity = findById(updater.id)

            when (updatedEntity) {
                is HistorySubOneEntity -> insertHistory(updatedEntity, ChangeType.UPDATE)
                is HistorySubTwoEntity -> insertHistory(updatedEntity, ChangeType.UPDATE)
            }

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "lastModifiedById" -> sqlParams.addValue("lastModifiedById", field.value as DomainId)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
        }

    }


    fun deleteById(id: DomainId): Boolean {

        val existingEntity = findByIdOrNull(id)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from testing.history_super where id = :id",
            SqlParams().apply {
                addValue("id", id)
            }
        )

        if (deletedCount > 0) {

            when (existingEntity) {
                is HistorySubOneEntity -> insertHistory(existingEntity, existingEntity.version + 1, ChangeType.DELETE)
                is HistorySubTwoEntity -> insertHistory(existingEntity, existingEntity.version + 1, ChangeType.DELETE)
            }

            return true

        } else {

            return false

        }

    }


    fun removeById(id: DomainId): HistorySuperEntity? {

        val found = findByIdOrNull(id)

        if (found != null) {
            deleteById(id)
        }

        return found

    }


}


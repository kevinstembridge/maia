// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.jdbc.sample.nullable

import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.sql.PreparedStatement


@Repository
class NullableFieldsDao(
    private val fieldConverter: NullableFieldsEntityFieldConverter,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = NullableFieldsEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    private val idRowMapper = MaiaRowMapper { rs -> rs.readDomainId("id") }


    fun insert(entity: NullableFieldsEntity) {

        jdbcOps.update(
            """
            insert into testing.nullable_fields (
                c_ts,
                id,
                some_boolean,
                some_boolean_type,
                some_enum,
                some_instant,
                some_int,
                some_int_type,
                some_local_date,
                some_long_type,
                some_period,
                some_provided_boolean_type,
                some_provided_int_type,
                some_provided_long_type,
                some_provided_string_type,
                some_string,
                some_string_type
            ) values (
                :createdTimestampUtc,
                :id,
                :someBoolean,
                :someBooleanType,
                :someEnum,
                :someInstant,
                :someInt,
                :someIntType,
                :someLocalDate,
                :someLongType,
                :somePeriod,
                :someProvidedBooleanType,
                :someProvidedIntType,
                :someProvidedLongType,
                :someProvidedStringType,
                :someString,
                :someStringType
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("someBoolean", entity.someBoolean)
                addValue("someBooleanType", entity.someBooleanType)
                addValue("someEnum", entity.someEnum)
                addValue("someInstant", entity.someInstant)
                addValue("someInt", entity.someInt)
                addValue("someIntType", entity.someIntType)
                addValue("someLocalDate", entity.someLocalDate)
                addValue("someLongType", entity.someLongType)
                addValue("somePeriod", entity.somePeriod)
                addValue("someProvidedBooleanType", entity.someProvidedBooleanType)
                addValue("someProvidedIntType", entity.someProvidedIntType)
                addValue("someProvidedLongType", entity.someProvidedLongType)
                addValue("someProvidedStringType", entity.someProvidedStringType)
                addValue("someString", entity.someString)
                addValue("someStringType", entity.someStringType)
            }
        )

    }


    fun bulkInsert(entities: List<NullableFieldsEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.nullable_fields (
                c_ts,
                id,
                some_boolean,
                some_boolean_type,
                some_enum,
                some_instant,
                some_int,
                some_int_type,
                some_local_date,
                some_long_type,
                some_period,
                some_provided_boolean_type,
                some_provided_int_type,
                some_provided_long_type,
                some_provided_string_type,
                some_string,
                some_string_type
            ) values (
                :createdTimestampUtc,
                :id,
                :someBoolean,
                :someBooleanType,
                :someEnum,
                :someInstant,
                :someInt,
                :someIntType,
                :someLocalDate,
                :someLongType,
                :somePeriod,
                :someProvidedBooleanType,
                :someProvidedIntType,
                :someProvidedLongType,
                :someProvidedStringType,
                :someString,
                :someStringType
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("someBoolean", entity.someBoolean)
                    addValue("someBooleanType", entity.someBooleanType)
                    addValue("someEnum", entity.someEnum)
                    addValue("someInstant", entity.someInstant)
                    addValue("someInt", entity.someInt)
                    addValue("someIntType", entity.someIntType)
                    addValue("someLocalDate", entity.someLocalDate)
                    addValue("someLongType", entity.someLongType)
                    addValue("somePeriod", entity.somePeriod)
                    addValue("someProvidedBooleanType", entity.someProvidedBooleanType)
                    addValue("someProvidedIntType", entity.someProvidedIntType)
                    addValue("someProvidedLongType", entity.someProvidedLongType)
                    addValue("someProvidedStringType", entity.someProvidedStringType)
                    addValue("someString", entity.someString)
                    addValue("someStringType", entity.someStringType)
                }
            }
        )

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.nullable_fields",
            SqlParams()
        )

    }


    fun count(filter: NullableFieldsEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.nullable_fields
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): NullableFieldsEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    NullableFieldsEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                NullableFieldsEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): NullableFieldsEntity? {

        return jdbcOps.queryForList(
            "select * from testing.nullable_fields where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.nullable_fields where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findOneOrNullBySomeString(someString: String): NullableFieldsEntity? {

        return jdbcOps.queryForList(
            """
            select * from testing.nullable_fields
            where some_string = :someString
            """.trimIndent(),
            SqlParams().apply {
            addValue("someString", someString)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    @Throws(EntityNotFoundException::class)
    fun findOneBySomeString(someString: String): NullableFieldsEntity {

        return findOneOrNullBySomeString(someString)
            ?: throw EntityNotFoundException("No record with column [some_string = $someString] found in table testing.nullable_fields.", NullableFieldsEntityMeta.TABLE_NAME)

    }


    fun findAllBy(filter: NullableFieldsEntityFilter): List<NullableFieldsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.nullable_fields where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: NullableFieldsEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from testing.nullable_fields where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.nullable_fields;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: NullableFieldsEntityFilter, pageable: Pageable): List<NullableFieldsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.nullable_fields where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<NullableFieldsEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.nullable_fields;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun existsBySomeString(someString: String): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from testing.nullable_fields
            where some_string = :someString
            """.trimIndent(),
            SqlParams().apply {
            addValue("someString", someString)
            }
        )

        return count > 0

    }


    fun upsertBySomeString(upsertEntity: NullableFieldsEntity): NullableFieldsEntityPk {

        return jdbcOps.execute(
            """
            with input_rows(
                c_ts,
                id,
                some_boolean,
                some_boolean_type,
                some_enum,
                some_instant,
                some_int,
                some_int_type,
                some_local_date,
                some_long_type,
                some_period,
                some_provided_boolean_type,
                some_provided_int_type,
                some_provided_long_type,
                some_provided_string_type,
                some_string,
                some_string_type
            ) as (
                values (
                    cast(:createdTimestampUtc as timestamp(3) with time zone),
                    cast(:id as uuid),
                    cast(:someBoolean as boolean),
                    cast(:someBooleanType as boolean),
                    cast(:someEnum as text),
                    cast(:someInstant as timestamp(3) with time zone),
                    cast(:someInt as integer),
                    cast(:someIntType as integer),
                    cast(:someLocalDate as date),
                    cast(:someLongType as bigint),
                    cast(:somePeriod as text),
                    cast(:someProvidedBooleanType as boolean),
                    cast(:someProvidedIntType as integer),
                    cast(:someProvidedLongType as bigint),
                    cast(:someProvidedStringType as text),
                    cast(:someString as text),
                    cast(:someStringType as text)
                )
            )
            , ins as (
                insert into testing.nullable_fields (
                    c_ts,
                    id,
                    some_boolean,
                    some_boolean_type,
                    some_enum,
                    some_instant,
                    some_int,
                    some_int_type,
                    some_local_date,
                    some_long_type,
                    some_period,
                    some_provided_boolean_type,
                    some_provided_int_type,
                    some_provided_long_type,
                    some_provided_string_type,
                    some_string,
                    some_string_type
                )
                select * from input_rows
                on conflict (some_string) do nothing
                returning id
            )
            select 'i' as source, id
            from ins
            union all
            select 's' as source, c.id
            from input_rows
            join testing.nullable_fields c using (some_string);
            """.trimIndent(),
            SqlParams().apply {
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("id", upsertEntity.id)
            addValue("someBoolean", upsertEntity.someBoolean)
            addValue("someBooleanType", upsertEntity.someBooleanType)
            addValue("someEnum", upsertEntity.someEnum)
            addValue("someInstant", upsertEntity.someInstant)
            addValue("someInt", upsertEntity.someInt)
            addValue("someIntType", upsertEntity.someIntType)
            addValue("someLocalDate", upsertEntity.someLocalDate)
            addValue("someLongType", upsertEntity.someLongType)
            addValue("somePeriod", upsertEntity.somePeriod)
            addValue("someProvidedBooleanType", upsertEntity.someProvidedBooleanType)
            addValue("someProvidedIntType", upsertEntity.someProvidedIntType)
            addValue("someProvidedLongType", upsertEntity.someProvidedLongType)
            addValue("someProvidedStringType", upsertEntity.someProvidedStringType)
            addValue("someString", upsertEntity.someString)
            addValue("someStringType", upsertEntity.someStringType)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                primaryKeyRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )!!

    }


}


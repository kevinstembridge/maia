// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.gen.testing.sample.person

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.LifecycleState
import org.maiaframework.domain.party.FirstName
import org.maiaframework.domain.party.LastName
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.gen.testing.sample.user.UserEntity
import org.maiaframework.gen.testing.sample.user.UserEntityMeta
import org.maiaframework.gen.testing.sample.user.UserHistoryDao
import org.maiaframework.gen.testing.sample.user.UserHistoryEntity
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.time.Instant


@Repository
class PersonDao(
    private val fieldConverter: PersonEntityFieldConverter,
    private val historyDao: PersonHistoryDao,
    private val jdbcOps: JdbcOps,
    private val personHistoryDao: PersonHistoryDao,
    private val userHistoryDao: UserHistoryDao
) {


    private val entityRowMapper = PersonEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    fun insert(entity: PersonEntity) {

        when (entity) {
            is UserEntity -> insertUserEntity(entity)
            is PersonEntity -> insertPersonEntity(entity)
        }

    }


    private fun insertUserEntity(entity: UserEntity) {

        jdbcOps.update(
            """
            insert into testing.v_party (
                type_discriminator,
                created_timestamp_utc,
                email_address,
                encrypted_password,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                some_strings,
                version
            ) values (
                :typeDiscriminator,
                :createdTimestampUtc,
                :emailAddress,
                :encryptedPassword,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :someStrings,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", UserEntityMeta.TYPE_DISCRIMINATOR)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("displayName", entity.displayName)
                addValue("emailAddress", entity.emailAddress)
                addValue("encryptedPassword", entity.encryptedPassword)
                addValue("firstName", entity.firstName)
                addValue("id", entity.id)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("lastName", entity.lastName)
                addValue("lifecycleState", entity.lifecycleState)
                addListOfStrings("someStrings", entity.someStrings)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    private fun insertPersonEntity(entity: PersonEntity) {

        jdbcOps.update(
            """
            insert into testing.v_party (
                type_discriminator,
                created_timestamp_utc,
                email_address,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                version
            ) values (
                :typeDiscriminator,
                :createdTimestampUtc,
                :emailAddress,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", PersonEntityMeta.TYPE_DISCRIMINATOR)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("displayName", entity.displayName)
                addValue("emailAddress", entity.emailAddress)
                addValue("firstName", entity.firstName)
                addValue("id", entity.id)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("lastName", entity.lastName)
                addValue("lifecycleState", entity.lifecycleState)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<PersonEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into testing.v_party (
                type_discriminator,
                created_timestamp_utc,
                email_address,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                version
            ) values (
                :typeDiscriminator,
                :createdTimestampUtc,
                :emailAddress,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("typeDiscriminator", PersonEntityMeta.TYPE_DISCRIMINATOR)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("displayName", entity.displayName)
                    addValue("emailAddress", entity.emailAddress)
                    addValue("firstName", entity.firstName)
                    addValue("id", entity.id)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("lastName", entity.lastName)
                    addValue("lifecycleState", entity.lifecycleState)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: UserEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: UserEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun insertHistory(entity: PersonEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: PersonEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<PersonEntity>, changeType: ChangeType) {

        val entitiesByType: Map<String, List<PersonEntity>> = entities.groupBy { entity ->
            when (entity) {
                is UserEntity -> "USR"
                is PersonEntity -> "PER"
                else -> throw RuntimeException("Not going to happen (tm)")
            }
        }

        val entitiesUSR: List<UserEntity> = entitiesByType["USR"] as? List<UserEntity> ?: emptyList()
        val userHistoryEntityList = entitiesUSR.map { history(it, it.version + 1, changeType) }
        this.userHistoryDao.bulkInsert(userHistoryEntityList)

        val entitiesPER: List<PersonEntity> = entitiesByType["PER"] as? List<PersonEntity> ?: emptyList()
        val personHistoryEntityList = entitiesPER.map { history(it, it.version + 1, changeType) }
        this.personHistoryDao.bulkInsert(personHistoryEntityList)

    }


    private fun history(
        entity: UserEntity,
        version: Long,
        changeType: ChangeType
    ): UserHistoryEntity {

        val id = entity.id
        val createdTimestampUtc = entity.createdTimestampUtc
        val displayName = entity.displayName
        val emailAddress = entity.emailAddress
        val encryptedPassword = entity.encryptedPassword
        val firstName = entity.firstName
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val lastName = entity.lastName
        val lifecycleState = entity.lifecycleState
        val someStrings = entity.someStrings

        return UserHistoryEntity(
                changeType,
                createdTimestampUtc,
                displayName,
                emailAddress,
                encryptedPassword,
                firstName,
                id,
                lastModifiedTimestampUtc,
                lastName,
                lifecycleState,
                someStrings,
                version)

    }


    private fun history(
        entity: PersonEntity,
        version: Long,
        changeType: ChangeType
    ): PersonHistoryEntity {

        val id = entity.id
        val createdTimestampUtc = entity.createdTimestampUtc
        val displayName = entity.displayName
        val emailAddress = entity.emailAddress
        val firstName = entity.firstName
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val lastName = entity.lastName
        val lifecycleState = entity.lifecycleState

        return PersonHistoryEntity(
                changeType,
                createdTimestampUtc,
                displayName,
                emailAddress,
                firstName,
                id,
                lastModifiedTimestampUtc,
                lastName,
                lifecycleState,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from testing.v_party",
            SqlParams()
        )

    }


    fun count(filter: PersonEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from testing.v_party
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): PersonEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    PersonEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                PersonEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): PersonEntity? {

        return jdbcOps.queryForList(
            "select * from testing.v_party where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from testing.v_party where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findAllBy(filter: PersonEntityFilter): List<PersonEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.v_party where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: PersonEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from testing.v_party where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from testing.v_party;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: PersonEntityFilter, pageable: Pageable): List<PersonEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from testing.v_party where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<PersonEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from testing.v_party;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun setFields(updaters: List<PersonEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: PersonEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update testing.v_party set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("version_incremented", "version", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")
        sql.append(" and version = :version")

        sqlParams.addValue("id", updater.id)

        sqlParams.addValue("version", updater.version)
        sqlParams.addValue("version_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(PersonEntityMeta.TABLE_NAME, updater.primaryKey, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.id)

            when (updatedEntity) {
                is UserEntity -> insertHistory(updatedEntity, ChangeType.UPDATE)
                is PersonEntity -> insertHistory(updatedEntity, ChangeType.UPDATE)
            }

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "firstName" -> sqlParams.addValue("firstName", field.value as FirstName?)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "lastName" -> sqlParams.addValue("lastName", field.value as LastName)
            "lifecycleState" -> sqlParams.addValue("lifecycleState", field.value as LifecycleState)
        }

    }


}


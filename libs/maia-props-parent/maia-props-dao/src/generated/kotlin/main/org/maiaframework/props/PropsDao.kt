// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.props

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndId
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import java.sql.PreparedStatement
import java.time.Instant


class PropsDao(
    private val fieldConverter: PropsEntityFieldConverter,
    private val historyDao: PropsHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = PropsEntityRowMapper()


    fun insert(entity: PropsEntity) {

        jdbcOps.update(
            """
            insert into props.props (
                comment,
                c_ts,
                id,
                last_modified_by,
                lm_ts,
                property_name,
                property_value,
                v
            ) values (
                :comment,
                :createdTimestampUtc,
                :id,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :propertyName,
                :propertyValue,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("comment", entity.comment)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("id", entity.id)
                addValue("lastModifiedBy", entity.lastModifiedBy)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("propertyName", entity.propertyName)
                addValue("propertyValue", entity.propertyValue)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<PropsEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into props.props (
                comment,
                c_ts,
                id,
                last_modified_by,
                lm_ts,
                property_name,
                property_value,
                v
            ) values (
                :comment,
                :createdTimestampUtc,
                :id,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :propertyName,
                :propertyValue,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("comment", entity.comment)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("id", entity.id)
                    addValue("lastModifiedBy", entity.lastModifiedBy)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("propertyName", entity.propertyName)
                    addValue("propertyValue", entity.propertyValue)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: PropsEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: PropsEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<PropsEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: PropsEntity,
        version: Long,
        changeType: ChangeType
    ): PropsHistoryEntity {

        val id = entity.id
        val comment = entity.comment
        val createdTimestampUtc = entity.createdTimestampUtc
        val lastModifiedBy = entity.lastModifiedBy
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val propertyName = entity.propertyName
        val propertyValue = entity.propertyValue

        return PropsHistoryEntity(
                changeType,
                comment,
                createdTimestampUtc,
                id,
                lastModifiedBy,
                lastModifiedTimestampUtc,
                propertyName,
                propertyValue,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from props.props",
            SqlParams()
        )

    }


    fun count(filter: PropsEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from props.props
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findById(id: DomainId): PropsEntity {

        return findByIdOrNull(id)
            ?: throw EntityNotFoundException(EntityClassAndId(PropsEntity::class.java, id), PropsEntityMeta.TABLE_NAME)

    }


    fun findByIdOrNull(id: DomainId): PropsEntity? {

        return jdbcOps.queryForList(
            "select * from props.props where id = :id",
            SqlParams().apply {
                addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun findOneOrNullByPropertyName(propertyName: String): PropsEntity? {

        return jdbcOps.queryForList(
            """
            select * from props.props
            where property_name = :propertyName
            """.trimIndent(),
            SqlParams().apply {
                addValue("propertyName", propertyName)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    @Throws(EntityNotFoundException::class)
    fun findOneByPropertyName(propertyName: String): PropsEntity {

        return findOneOrNullByPropertyName(propertyName)
            ?: throw EntityNotFoundException("No record with column [property_name = $propertyName] found in table props.props.", PropsEntityMeta.TABLE_NAME)

    }


    fun findAll(): List<PropsEntity> {

        return this.jdbcOps.queryForList(
            "select * from props.props",
            SqlParams(),
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: PropsEntityFilter): List<PropsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from props.props where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllByFilterAsSequence(filter: PropsEntityFilter): Sequence<PropsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select * from props.props where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findIdsAsSequence(filter: PropsEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from props.props where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllIdsAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from props.props;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: PropsEntityFilter, pageable: Pageable): List<PropsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from props.props where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<PropsEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from props.props;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun existsByPropertyName(propertyName: String): Boolean {

        val count = jdbcOps.queryForInt(
            """
            select count(*) from props.props
            where property_name = :propertyName
            """.trimIndent(),
            SqlParams().apply {
                addValue("propertyName", propertyName)
            }
        )

        return count > 0

    }


    fun upsertByPropertyName(upsertEntity: PropsEntity): PropsEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into props.props (
                comment,
                c_ts,
                id,
                last_modified_by,
                lm_ts,
                property_name,
                property_value,
                v
            ) values (
                :comment,
                :createdTimestampUtc,
                :id,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :propertyName,
                :propertyValue,
                :version
            )
            on conflict (property_name)
            do update set
                last_modified_by = :lastModifiedBy,
                lm_ts = :lastModifiedTimestampUtc,
                property_value = :propertyValue,
                v = props.props.v + 1
            returning *;
            """.trimIndent(),
            SqlParams().apply {
                addValue("comment", upsertEntity.comment)
                addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
                addValue("id", upsertEntity.id)
                addValue("lastModifiedBy", upsertEntity.lastModifiedBy)
                addValue("lastModifiedTimestampUtc", upsertEntity.lastModifiedTimestampUtc)
                addValue("propertyName", upsertEntity.propertyName)
                addValue("propertyValue", upsertEntity.propertyValue)
                addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        val changeType = if (persistedEntity!!.id != upsertEntity.id) ChangeType.UPDATE else ChangeType.CREATE
        insertHistory(persistedEntity, persistedEntity.version, changeType)

        return persistedEntity!!

    }


    fun setFields(updaters: List<PropsEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: PropsEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update props.props set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("v_incremented", "v", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")
        sql.append(" and v = :v")

        sqlParams.addValue("id", updater.id)
        sqlParams.addValue("v", updater.version)
        sqlParams.addValue("v_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(PropsEntityMeta.TABLE_NAME, updater.id, updater.version)

        } else {

            val updatedEntity = findById(updater.id)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "lastModifiedBy" -> sqlParams.addValue("lastModifiedBy", field.value as String)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "propertyValue" -> sqlParams.addValue("propertyValue", field.value as String)
        }

    }


    fun deleteById(id: DomainId): Boolean {

        val existingEntity = findByIdOrNull(id)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from props.props where id = :id",
            SqlParams().apply {
                addValue("id", id)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeById(id: DomainId): PropsEntity? {

        val found = findByIdOrNull(id)

        if (found != null) {
            deleteById(id)
        }

        return found

    }


    fun deleteByPropertyName(propertyName: String): Boolean {

        val existingEntity = findOneOrNullByPropertyName(propertyName)

        if (existingEntity != null) {

            val deletedCount = this.jdbcOps.update(
                "delete from props.props where id = :id",
                SqlParams().apply {
                    addValue("id", existingEntity.id)
                }
            )

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))

            return deletedCount > 0

        } else {

            return false

        }

    }


}


// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.props

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import java.sql.PreparedStatement
import java.time.Instant


class PropsDao(
    private val fieldConverter: PropsEntityFieldConverter,
    private val historyDao: PropsHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = PropsEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readString("property_name") }


    fun insert(entity: PropsEntity) {

        jdbcOps.update(
            """
            insert into props.props (
                comment,
                created_timestamp_utc,
                last_modified_by_name,
                last_modified_timestamp_utc,
                property_name,
                property_value,
                version
            ) values (
                :comment,
                :createdTimestampUtc,
                :lastModifiedByUsername,
                :lastModifiedTimestampUtc,
                :propertyName,
                :propertyValue,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("comment", entity.comment)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("lastModifiedByUsername", entity.lastModifiedByUsername)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("propertyName", entity.propertyName)
                addValue("propertyValue", entity.propertyValue)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<PropsEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into props.props (
                comment,
                created_timestamp_utc,
                last_modified_by_name,
                last_modified_timestamp_utc,
                property_name,
                property_value,
                version
            ) values (
                :comment,
                :createdTimestampUtc,
                :lastModifiedByUsername,
                :lastModifiedTimestampUtc,
                :propertyName,
                :propertyValue,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("comment", entity.comment)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("lastModifiedByUsername", entity.lastModifiedByUsername)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("propertyName", entity.propertyName)
                    addValue("propertyValue", entity.propertyValue)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: PropsEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: PropsEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<PropsEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: PropsEntity,
        version: Long,
        changeType: ChangeType
    ): PropsHistoryEntity {

        val comment = entity.comment
        val createdTimestampUtc = entity.createdTimestampUtc
        val lastModifiedByUsername = entity.lastModifiedByUsername
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val propertyName = entity.propertyName
        val propertyValue = entity.propertyValue

        return PropsHistoryEntity(
                changeType,
                comment,
                createdTimestampUtc,
                lastModifiedByUsername,
                lastModifiedTimestampUtc,
                propertyName,
                propertyValue,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from props.props",
            SqlParams()
        )

    }


    fun count(filter: PropsEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from props.props
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(propertyName: String): PropsEntity {

        return findByPrimaryKeyOrNull(propertyName)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    PropsEntity::class.java,
                    mapOf(
                        "propertyName" to propertyName,
                    )
                ),
                PropsEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(propertyName: String): PropsEntity? {

        return jdbcOps.queryForList(
            "select * from props.props where property_name = :propertyName",
            SqlParams().apply {
            addValue("propertyName", propertyName)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(propertyName: String): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from props.props where property_name = :propertyName",
            SqlParams().apply {
                addValue("propertyName", propertyName)
           }
        )
       
        return count > 0
       
    }

    fun findAll(): List<PropsEntity> {

        return this.jdbcOps.queryForList(
            "select * from props.props",
            SqlParams(),
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: PropsEntityFilter): List<PropsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from props.props where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllByFilterAsSequence(filter: PropsEntityFilter): Sequence<PropsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select * from props.props where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: PropsEntityFilter): Sequence<String> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select property_name from props.props where $whereClause",
            sqlParams,
            this.primaryKeyRowMapper
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<String> {

        return this.jdbcOps.queryForSequence(
            "select property_name from props.props;",
            SqlParams(),
            this.primaryKeyRowMapper
        )

    }


    fun findAllBy(filter: PropsEntityFilter, pageable: Pageable): List<PropsEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from props.props where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<PropsEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from props.props;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun upsertByPropertyName(upsertEntity: PropsEntity): PropsEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into props.props (
                comment,
                created_timestamp_utc,
                last_modified_by_name,
                last_modified_timestamp_utc,
                property_name,
                property_value,
                version
            ) values (
                :comment,
                :createdTimestampUtc,
                :lastModifiedByUsername,
                :lastModifiedTimestampUtc,
                :propertyName,
                :propertyValue,
                :version
            )
            on conflict (property_name)
            do update set
                last_modified_by_name = :lastModifiedByUsername,
                last_modified_timestamp_utc = :lastModifiedTimestampUtc,
                property_value = :propertyValue,
                version = props.props.version + 1
            returning *;
            """.trimIndent(),
            SqlParams().apply {
            addValue("comment", upsertEntity.comment)
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("lastModifiedByUsername", upsertEntity.lastModifiedByUsername)
            addValue("lastModifiedTimestampUtc", upsertEntity.lastModifiedTimestampUtc)
            addValue("propertyName", upsertEntity.propertyName)
            addValue("propertyValue", upsertEntity.propertyValue)
            addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        val changeType = if (persistedEntity!!.primaryKey != upsertEntity.primaryKey) ChangeType.UPDATE else ChangeType.CREATE
        insertHistory(persistedEntity, persistedEntity.version, changeType)

        return persistedEntity!!

    }


    fun setFields(updaters: List<PropsEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: PropsEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update props.props set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("version_incremented", "version", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where property_name = :propertyName")
        sql.append(" and version = :version")

        sqlParams.addValue("propertyName", updater.propertyName)

        sqlParams.addValue("version", updater.version)
        sqlParams.addValue("version_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(PropsEntityMeta.TABLE_NAME, updater.primaryKeyMap, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.propertyName)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "lastModifiedByUsername" -> sqlParams.addValue("lastModifiedByUsername", field.value as String)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "propertyValue" -> sqlParams.addValue("propertyValue", field.value as String)
        }

    }


    fun deleteByPrimaryKey(propertyName: String): Boolean {

        val existingEntity = findByPrimaryKeyOrNull(propertyName)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from props.props where property_name = :propertyName",
            SqlParams().apply {
                addValue("propertyName", propertyName)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeByPrimaryKey(propertyName: String): PropsEntity? {

        val found = findByPrimaryKeyOrNull(propertyName)

        if (found != null) {
            deleteByPrimaryKey(propertyName)
        }

        return found

    }


}


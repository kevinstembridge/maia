// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.toggles

import com.fasterxml.jackson.databind.ObjectMapper
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndId
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.SqlParams
import org.maiaframework.json.JsonFacade
import org.springframework.data.domain.Pageable


class FeatureToggleHistoryDao(
    private val fieldConverter: FeatureToggleHistoryEntityFieldConverter,
    private val jdbcOps: JdbcOps,
    private val jsonFacade: JsonFacade,
    private val objectMapper: ObjectMapper
) {


    private val entityRowMapper = FeatureToggleHistoryEntityRowMapper(objectMapper)


    fun insert(entity: FeatureToggleHistoryEntity) {

        jdbcOps.update(
            """
            insert into toggles.feature_toggle_history (
                activation_strategies,
                attributes,
                change_type,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :changeType,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                addJsonValue("attributes", objectMapper.writeValueAsString(entity.attributes))
                addValue("changeType", entity.changeType)
                addValue("comment", entity.comment)
                addValue("contactPerson", entity.contactPerson?.value)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("description", entity.description?.value)
                addValue("enabled", entity.enabled)
                addValue("featureName", entity.featureName.value)
                addValue("infoLink", entity.infoLink?.value)
                addValue("lastModifiedBy", entity.lastModifiedBy)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("reviewDate", entity.reviewDate)
                addValue("ticketKey", entity.ticketKey?.value)
                addValue("version", entity.version)
            }
        )

    }


    fun bulkInsert(entities: List<FeatureToggleHistoryEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into toggles.feature_toggle_history (
                activation_strategies,
                attributes,
                change_type,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :changeType,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                    addJsonValue("attributes", objectMapper.writeValueAsString(entity.attributes))
                    addValue("changeType", entity.changeType)
                    addValue("comment", entity.comment)
                    addValue("contactPerson", entity.contactPerson?.value)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("description", entity.description?.value)
                    addValue("enabled", entity.enabled)
                    addValue("featureName", entity.featureName.value)
                    addValue("infoLink", entity.infoLink?.value)
                    addValue("lastModifiedBy", entity.lastModifiedBy)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("reviewDate", entity.reviewDate)
                    addValue("ticketKey", entity.ticketKey?.value)
                    addValue("version", entity.version)
                }
            }
        )

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from toggles.feature_toggle_history",
            SqlParams()
        )

    }


    fun count(filter: FeatureToggleHistoryEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from toggles.feature_toggle_history
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByFeatureNameAndVersion(featureName: FeatureName, version: Long): FeatureToggleHistoryEntity {

        return findByFeatureNameAndVersionOrNull(featureName, version)
            ?: throw EntityNotFoundException(EntityClassAndId(FeatureToggleHistoryEntity::class.java, id), FeatureToggleHistoryEntityMeta.TABLE_NAME)

    }


    fun findByFeatureNameAndVersionOrNull(featureName: FeatureName, version: Long): FeatureToggleHistoryEntity? {

        return jdbcOps.queryForList(
            "select * from toggles.feature_toggle_history where feature_name = :featureName and v = :version",
            SqlParams().apply {
                addValue("featureName", featureName)
                addValue("version", version)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun findAllBy(filter: FeatureToggleHistoryEntityFilter): List<FeatureToggleHistoryEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle_history where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllIdsAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from toggles.feature_toggle_history;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: FeatureToggleHistoryEntityFilter, pageable: Pageable): List<FeatureToggleHistoryEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle_history where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<FeatureToggleHistoryEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle_history;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


}


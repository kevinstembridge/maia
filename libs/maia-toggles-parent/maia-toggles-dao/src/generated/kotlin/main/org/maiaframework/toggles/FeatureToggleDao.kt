// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.toggles

import com.fasterxml.jackson.databind.ObjectMapper
import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.maiaframework.json.JsonFacade
import org.maiaframework.toggles.activation.ActivationStrategyDescriptor
import org.maiaframework.toggles.fields.ContactPerson
import org.maiaframework.toggles.fields.Description
import org.maiaframework.toggles.fields.InfoLink
import org.maiaframework.toggles.fields.TicketKey
import org.springframework.data.domain.Pageable
import java.sql.PreparedStatement
import java.time.Instant
import java.time.LocalDate


class FeatureToggleDao(
    private val fieldConverter: FeatureToggleEntityFieldConverter,
    private val historyDao: FeatureToggleHistoryDao,
    private val jdbcOps: JdbcOps,
    private val jsonFacade: JsonFacade,
    private val objectMapper: ObjectMapper
) {


    private val entityRowMapper = FeatureToggleEntityRowMapper(objectMapper)


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readString("feature_name") { FeatureName(it) } }
    private val fetchForEditDtoRowMapper = FeatureToggleFetchForEditDtoRowMapper(objectMapper)


    fun insert(entity: FeatureToggleEntity) {

        jdbcOps.update(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                created_timestamp_utc,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by_name,
                last_modified_timestamp_utc,
                review_date,
                ticket_key,
                version
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedByUsername,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                addJsonValue("attributes", entity.attributes?.let { objectMapper.writeValueAsString(it) })
                addValue("comment", entity.comment)
                addValue("contactPerson", entity.contactPerson?.value)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("description", entity.description?.value)
                addValue("enabled", entity.enabled)
                addValue("featureName", entity.featureName.value)
                addValue("infoLink", entity.infoLink?.value)
                addValue("lastModifiedByUsername", entity.lastModifiedByUsername)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("reviewDate", entity.reviewDate)
                addValue("ticketKey", entity.ticketKey?.value)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<FeatureToggleEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                created_timestamp_utc,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by_name,
                last_modified_timestamp_utc,
                review_date,
                ticket_key,
                version
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedByUsername,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                    addJsonValue("attributes", entity.attributes?.let { objectMapper.writeValueAsString(it) })
                    addValue("comment", entity.comment)
                    addValue("contactPerson", entity.contactPerson?.value)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("description", entity.description?.value)
                    addValue("enabled", entity.enabled)
                    addValue("featureName", entity.featureName.value)
                    addValue("infoLink", entity.infoLink?.value)
                    addValue("lastModifiedByUsername", entity.lastModifiedByUsername)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("reviewDate", entity.reviewDate)
                    addValue("ticketKey", entity.ticketKey?.value)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: FeatureToggleEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: FeatureToggleEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<FeatureToggleEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: FeatureToggleEntity,
        version: Long,
        changeType: ChangeType
    ): FeatureToggleHistoryEntity {

        val activationStrategies = entity.activationStrategies
        val attributes = entity.attributes
        val comment = entity.comment
        val contactPerson = entity.contactPerson
        val createdTimestampUtc = entity.createdTimestampUtc
        val description = entity.description
        val enabled = entity.enabled
        val featureName = entity.featureName
        val infoLink = entity.infoLink
        val lastModifiedByUsername = entity.lastModifiedByUsername
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val reviewDate = entity.reviewDate
        val ticketKey = entity.ticketKey

        return FeatureToggleHistoryEntity(
                activationStrategies,
                attributes,
                changeType,
                comment,
                contactPerson,
                createdTimestampUtc,
                description,
                enabled,
                featureName,
                infoLink,
                lastModifiedByUsername,
                lastModifiedTimestampUtc,
                reviewDate,
                ticketKey,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from toggles.feature_toggle",
            SqlParams()
        )

    }


    fun count(filter: FeatureToggleEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from toggles.feature_toggle
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(featureName: FeatureName): FeatureToggleEntity {

        return findByPrimaryKeyOrNull(featureName)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    FeatureToggleEntity::class.java,
                    mapOf(
                        "featureName" to featureName,
                    )
                ),
                FeatureToggleEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(featureName: FeatureName): FeatureToggleEntity? {

        return jdbcOps.queryForList(
            "select * from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
            addValue("featureName", featureName.value)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(featureName: FeatureName): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
                addValue("featureName", featureName.value)
           }
        )
       
        return count > 0
       
    }

    fun findAll(): List<FeatureToggleEntity> {

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle",
            SqlParams(),
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: FeatureToggleEntityFilter): List<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllByFilterAsSequence(filter: FeatureToggleEntityFilter): Sequence<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: FeatureToggleEntityFilter): Sequence<FeatureName> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select feature_name from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.primaryKeyRowMapper
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<FeatureName> {

        return this.jdbcOps.queryForSequence(
            "select feature_name from toggles.feature_toggle;",
            SqlParams(),
            this.primaryKeyRowMapper
        )

    }


    fun findAllBy(filter: FeatureToggleEntityFilter, pageable: Pageable): List<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<FeatureToggleEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun fetchForEdit(featureName: FeatureName): FeatureToggleFetchForEditDto {

        return this.jdbcOps.queryForList(
            """
            select
                feature_toggle.activation_strategies as activationStrategies,
                feature_toggle.attributes as attributes,
                feature_toggle.comment as comment,
                feature_toggle.contact_person as contactPerson,
                feature_toggle.created_timestamp_utc as createdTimestampUtc,
                feature_toggle.description as description,
                feature_toggle.enabled as enabled,
                feature_toggle.feature_name as featureName,
                feature_toggle.info_link as infoLink,
                feature_toggle.last_modified_by_name as lastModifiedByUsername,
                feature_toggle.last_modified_timestamp_utc as lastModifiedTimestampUtc,
                feature_toggle.review_date as reviewDate,
                feature_toggle.ticket_key as ticketKey,
                feature_toggle.version as version
            from toggles.feature_toggle
            where feature_toggle.feature_name = :featureName
            """,
            SqlParams().apply {
                addValue("featureName", featureName.value)
            },
            this.fetchForEditDtoRowMapper
        ).firstOrNull()
            ?: throw EntityNotFoundException(EntityClassAndPk(FeatureToggleEntity::class.java, mapOf("featureName" to featureName)), FeatureToggleEntityMeta.TABLE_NAME)

    }


    fun upsertByFeatureName(upsertEntity: FeatureToggleEntity): FeatureToggleEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                created_timestamp_utc,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by_name,
                last_modified_timestamp_utc,
                review_date,
                ticket_key,
                version
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedByUsername,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            on conflict (feature_name)
            do update set
                activation_strategies = :activationStrategies,
                attributes = :attributes,
                comment = :comment,
                contact_person = :contactPerson,
                description = :description,
                enabled = :enabled,
                info_link = :infoLink,
                last_modified_by_name = :lastModifiedByUsername,
                last_modified_timestamp_utc = :lastModifiedTimestampUtc,
                review_date = :reviewDate,
                ticket_key = :ticketKey,
                version = toggles.feature_toggle.version + 1
            returning *;
            """.trimIndent(),
            SqlParams().apply {
            addJsonValue("activationStrategies", objectMapper.writeValueAsString(upsertEntity.activationStrategies))
            addJsonValue("attributes", upsertEntity.attributes?.let { objectMapper.writeValueAsString(it) })
            addValue("comment", upsertEntity.comment)
            addValue("contactPerson", upsertEntity.contactPerson?.value)
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("description", upsertEntity.description?.value)
            addValue("enabled", upsertEntity.enabled)
            addValue("featureName", upsertEntity.featureName.value)
            addValue("infoLink", upsertEntity.infoLink?.value)
            addValue("lastModifiedByUsername", upsertEntity.lastModifiedByUsername)
            addValue("lastModifiedTimestampUtc", upsertEntity.lastModifiedTimestampUtc)
            addValue("reviewDate", upsertEntity.reviewDate)
            addValue("ticketKey", upsertEntity.ticketKey?.value)
            addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        val changeType = if (persistedEntity!!.primaryKey != upsertEntity.primaryKey) ChangeType.UPDATE else ChangeType.CREATE
        insertHistory(persistedEntity, persistedEntity.version, changeType)

        return persistedEntity!!

    }


    fun setFields(updaters: List<FeatureToggleEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: FeatureToggleEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update toggles.feature_toggle set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("version_incremented", "version", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where feature_name = :featureName")
        sql.append(" and version = :version")

        sqlParams.addValue("featureName", updater.featureName.value)

        sqlParams.addValue("version", updater.version)
        sqlParams.addValue("version_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(FeatureToggleEntityMeta.TABLE_NAME, updater.primaryKey, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.featureName)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "activationStrategies" -> sqlParams.addJsonValue("activationStrategies", this.objectMapper.writeValueAsString(field.value as List<ActivationStrategyDescriptor>))
            "attributes" -> sqlParams.addJsonValue("attributes", this.objectMapper.writeValueAsString(field.value as Map<*, *>?))
            "comment" -> sqlParams.addValue("comment", field.value as String?)
            "contactPerson" -> sqlParams.addValue("contactPerson", (field.value as ContactPerson?)?.value)
            "description" -> sqlParams.addValue("description", (field.value as Description?)?.value)
            "enabled" -> sqlParams.addValue("enabled", field.value as Boolean)
            "infoLink" -> sqlParams.addValue("infoLink", (field.value as InfoLink?)?.value)
            "lastModifiedByUsername" -> sqlParams.addValue("lastModifiedByUsername", field.value as String)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "reviewDate" -> sqlParams.addValue("reviewDate", field.value as LocalDate?)
            "ticketKey" -> sqlParams.addValue("ticketKey", (field.value as TicketKey?)?.value)
        }

    }


    fun deleteByPrimaryKey(featureName: FeatureName): Boolean {

        val existingEntity = findByPrimaryKeyOrNull(featureName)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
                addValue("featureName", featureName.value)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeByPrimaryKey(featureName: FeatureName): FeatureToggleEntity? {

        val found = findByPrimaryKeyOrNull(featureName)

        if (found != null) {
            deleteByPrimaryKey(featureName)
        }

        return found

    }


}


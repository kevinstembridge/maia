// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.toggles

import com.fasterxml.jackson.databind.ObjectMapper
import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndId
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.SqlParams
import org.maiaframework.json.JsonFacade
import org.maiaframework.toggles.fields.ContactPerson
import org.maiaframework.toggles.fields.Description
import org.maiaframework.toggles.fields.InfoLink
import org.maiaframework.toggles.fields.TicketKey
import org.springframework.data.domain.Pageable
import java.time.Instant
import java.time.LocalDate


class FeatureToggleDao(
    private val fieldConverter: FeatureToggleEntityFieldConverter,
    private val historyDao: FeatureToggleHistoryDao,
    private val jdbcOps: JdbcOps,
    private val jsonFacade: JsonFacade,
    private val objectMapper: ObjectMapper
) {


    private val entityRowMapper = FeatureToggleEntityRowMapper(objectMapper)


    fun insert(entity: FeatureToggleEntity) {

        jdbcOps.update(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                addJsonValue("attributes", objectMapper.writeValueAsString(entity.attributes))
                addValue("comment", entity.comment)
                addValue("contactPerson", entity.contactPerson?.value)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("description", entity.description?.value)
                addValue("enabled", entity.enabled)
                addValue("featureName", entity.featureName.value)
                addValue("infoLink", entity.infoLink?.value)
                addValue("lastModifiedBy", entity.lastModifiedBy)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("reviewDate", entity.reviewDate)
                addValue("ticketKey", entity.ticketKey?.value)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<FeatureToggleEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                    addJsonValue("attributes", objectMapper.writeValueAsString(entity.attributes))
                    addValue("comment", entity.comment)
                    addValue("contactPerson", entity.contactPerson?.value)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("description", entity.description?.value)
                    addValue("enabled", entity.enabled)
                    addValue("featureName", entity.featureName.value)
                    addValue("infoLink", entity.infoLink?.value)
                    addValue("lastModifiedBy", entity.lastModifiedBy)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("reviewDate", entity.reviewDate)
                    addValue("ticketKey", entity.ticketKey?.value)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: FeatureToggleEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: FeatureToggleEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<FeatureToggleEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: FeatureToggleEntity,
        version: Long,
        changeType: ChangeType
    ): FeatureToggleHistoryEntity {

        val id = entity.id
        val activationStrategies = entity.activationStrategies
        val attributes = entity.attributes
        val comment = entity.comment
        val contactPerson = entity.contactPerson
        val createdTimestampUtc = entity.createdTimestampUtc
        val description = entity.description
        val enabled = entity.enabled
        val featureName = entity.featureName
        val infoLink = entity.infoLink
        val lastModifiedBy = entity.lastModifiedBy
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val reviewDate = entity.reviewDate
        val ticketKey = entity.ticketKey

        return FeatureToggleHistoryEntity(
                activationStrategies,
                attributes,
                changeType,
                comment,
                contactPerson,
                createdTimestampUtc,
                description,
                enabled,
                featureName,
                infoLink,
                lastModifiedBy,
                lastModifiedTimestampUtc,
                reviewDate,
                ticketKey,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from toggles.feature_toggle",
            SqlParams()
        )

    }


    fun count(filter: FeatureToggleEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from toggles.feature_toggle
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByFeatureName(featureName: FeatureName): FeatureToggleEntity {

        return findByFeatureNameOrNull(featureName)
            ?: throw EntityNotFoundException(EntityClassAndId(FeatureToggleEntity::class.java, id), FeatureToggleEntityMeta.TABLE_NAME)

    }


    fun findByFeatureNameOrNull(featureName: FeatureName): FeatureToggleEntity? {

        return jdbcOps.queryForList(
            "select * from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
                addValue("featureName", featureName)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun findAll(): List<FeatureToggleEntity> {

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle",
            SqlParams(),
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: FeatureToggleEntityFilter): List<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllByFilterAsSequence(filter: FeatureToggleEntityFilter): Sequence<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findIdsAsSequence(filter: FeatureToggleEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from toggles.feature_toggle where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllIdsAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from toggles.feature_toggle;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: FeatureToggleEntityFilter, pageable: Pageable): List<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<FeatureToggleEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun setFields(updaters: List<FeatureToggleEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: FeatureToggleEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update toggles.feature_toggle set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("v_incremented", "v", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")
        sql.append(" and v = :v")

        sqlParams.addValue("id", updater.id)
        sqlParams.addValue("v", updater.version)
        sqlParams.addValue("v_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(FeatureToggleEntityMeta.TABLE_NAME, updater.id, updater.version)

        } else {

            val updatedEntity = findById(updater.id)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "contactPerson" -> sqlParams.addValue("contactPerson", (field.value as ContactPerson?)?.value)
            "description" -> sqlParams.addValue("description", (field.value as Description?)?.value)
            "enabled" -> sqlParams.addValue("enabled", field.value as Boolean)
            "infoLink" -> sqlParams.addValue("infoLink", (field.value as InfoLink?)?.value)
            "lastModifiedBy" -> sqlParams.addValue("lastModifiedBy", field.value as String)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "reviewDate" -> sqlParams.addValue("reviewDate", field.value as LocalDate?)
            "ticketKey" -> sqlParams.addValue("ticketKey", (field.value as TicketKey?)?.value)
        }

    }


    fun deleteById(id: DomainId): Boolean {

        val existingEntity = findByIdOrNull(id)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from toggles.feature_toggle where id = :id",
            SqlParams().apply {
                addValue("id", id)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeById(id: DomainId): FeatureToggleEntity? {

        val found = findByIdOrNull(id)

        if (found != null) {
            deleteById(id)
        }

        return found

    }


}


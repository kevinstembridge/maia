// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.toggles

import com.fasterxml.jackson.databind.ObjectMapper
import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.ResultSetAdapter
import org.maiaframework.jdbc.SqlParams
import org.maiaframework.json.JsonFacade
import org.maiaframework.toggles.fields.ContactPerson
import org.maiaframework.toggles.fields.Description
import org.maiaframework.toggles.fields.InfoLink
import org.maiaframework.toggles.fields.TicketKey
import org.springframework.data.domain.Pageable
import java.sql.PreparedStatement
import java.time.Instant
import java.time.LocalDate


class FeatureToggleDao(
    private val fieldConverter: FeatureToggleEntityFieldConverter,
    private val historyDao: FeatureToggleHistoryDao,
    private val jdbcOps: JdbcOps,
    private val jsonFacade: JsonFacade,
    private val objectMapper: ObjectMapper
) {


    private val entityRowMapper = FeatureToggleEntityRowMapper(objectMapper)


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readString("feature_name") { FeatureName(it) } }


    fun insert(entity: FeatureToggleEntity) {

        jdbcOps.update(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                addJsonValue("attributes", entity.attributes?.let { objectMapper.writeValueAsString(it) })
                addValue("comment", entity.comment)
                addValue("contactPerson", entity.contactPerson?.value)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("description", entity.description?.value)
                addValue("enabled", entity.enabled)
                addValue("featureName", entity.featureName.value)
                addValue("infoLink", entity.infoLink?.value)
                addValue("lastModifiedBy", entity.lastModifiedBy)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("reviewDate", entity.reviewDate)
                addValue("ticketKey", entity.ticketKey?.value)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<FeatureToggleEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addJsonValue("activationStrategies", objectMapper.writeValueAsString(entity.activationStrategies))
                    addJsonValue("attributes", entity.attributes?.let { objectMapper.writeValueAsString(it) })
                    addValue("comment", entity.comment)
                    addValue("contactPerson", entity.contactPerson?.value)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("description", entity.description?.value)
                    addValue("enabled", entity.enabled)
                    addValue("featureName", entity.featureName.value)
                    addValue("infoLink", entity.infoLink?.value)
                    addValue("lastModifiedBy", entity.lastModifiedBy)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("reviewDate", entity.reviewDate)
                    addValue("ticketKey", entity.ticketKey?.value)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: FeatureToggleEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: FeatureToggleEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<FeatureToggleEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: FeatureToggleEntity,
        version: Long,
        changeType: ChangeType
    ): FeatureToggleHistoryEntity {

        val activationStrategies = entity.activationStrategies
        val attributes = entity.attributes
        val comment = entity.comment
        val contactPerson = entity.contactPerson
        val createdTimestampUtc = entity.createdTimestampUtc
        val description = entity.description
        val enabled = entity.enabled
        val featureName = entity.featureName
        val infoLink = entity.infoLink
        val lastModifiedBy = entity.lastModifiedBy
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val reviewDate = entity.reviewDate
        val ticketKey = entity.ticketKey

        return FeatureToggleHistoryEntity(
                activationStrategies,
                attributes,
                changeType,
                comment,
                contactPerson,
                createdTimestampUtc,
                description,
                enabled,
                featureName,
                infoLink,
                lastModifiedBy,
                lastModifiedTimestampUtc,
                reviewDate,
                ticketKey,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from toggles.feature_toggle",
            SqlParams()
        )

    }


    fun count(filter: FeatureToggleEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from toggles.feature_toggle
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(featureName: FeatureName): FeatureToggleEntity {

        return findByPrimaryKeyOrNull(featureName)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    FeatureToggleEntity::class.java,
                    mapOf(
                        "featureName" to featureName,
                    )
                ),
                FeatureToggleEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(featureName: FeatureName): FeatureToggleEntity? {

        return jdbcOps.queryForList(
            "select * from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
            addValue("featureName", featureName.value)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(featureName: FeatureName): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
                addValue("featureName", featureName.value)
           }
        )
       
        return count > 0
       
    }

    fun findAll(): List<FeatureToggleEntity> {

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle",
            SqlParams(),
            this.entityRowMapper
        )

    }


    fun findAllBy(filter: FeatureToggleEntityFilter): List<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findAllByFilterAsSequence(filter: FeatureToggleEntityFilter): Sequence<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: FeatureToggleEntityFilter): Sequence<FeatureName> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select feature_name from toggles.feature_toggle where $whereClause",
            sqlParams,
            this.primaryKeyRowMapper
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<FeatureName> {

        return this.jdbcOps.queryForSequence(
            "select feature_name from toggles.feature_toggle;",
            SqlParams(),
            this.primaryKeyRowMapper
        )

    }


    fun findAllBy(filter: FeatureToggleEntityFilter, pageable: Pageable): List<FeatureToggleEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from toggles.feature_toggle where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<FeatureToggleEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from toggles.feature_toggle;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun upsertByFeatureName(upsertEntity: FeatureToggleEntity): FeatureToggleEntity {

        val persistedEntity = jdbcOps.execute(
            """
            insert into toggles.feature_toggle (
                activation_strategies,
                attributes,
                comment,
                contact_person,
                c_ts,
                description,
                enabled,
                feature_name,
                info_link,
                last_modified_by,
                lm_ts,
                review_date,
                ticket_key,
                v
            ) values (
                :activationStrategies,
                :attributes,
                :comment,
                :contactPerson,
                :createdTimestampUtc,
                :description,
                :enabled,
                :featureName,
                :infoLink,
                :lastModifiedBy,
                :lastModifiedTimestampUtc,
                :reviewDate,
                :ticketKey,
                :version
            )
            on conflict (feature_name)
            do update set
                contact_person = :contactPerson,
                description = :description,
                enabled = :enabled,
                info_link = :infoLink,
                last_modified_by = :lastModifiedBy,
                lm_ts = :lastModifiedTimestampUtc,
                review_date = :reviewDate,
                ticket_key = :ticketKey,
                v = toggles.feature_toggle.v + 1
            returning *;
            """.trimIndent(),
            SqlParams().apply {
            addJsonValue("activationStrategies", objectMapper.writeValueAsString(upsertEntity.activationStrategies))
            addJsonValue("attributes", upsertEntity.attributes?.let { objectMapper.writeValueAsString(it) })
            addValue("comment", upsertEntity.comment)
            addValue("contactPerson", upsertEntity.contactPerson?.value)
            addValue("createdTimestampUtc", upsertEntity.createdTimestampUtc)
            addValue("description", upsertEntity.description?.value)
            addValue("enabled", upsertEntity.enabled)
            addValue("featureName", upsertEntity.featureName.value)
            addValue("infoLink", upsertEntity.infoLink?.value)
            addValue("lastModifiedBy", upsertEntity.lastModifiedBy)
            addValue("lastModifiedTimestampUtc", upsertEntity.lastModifiedTimestampUtc)
            addValue("reviewDate", upsertEntity.reviewDate)
            addValue("ticketKey", upsertEntity.ticketKey?.value)
            addValue("version", upsertEntity.version)
            },
            { ps: PreparedStatement ->
                val rs = ps.executeQuery()
                rs.next()
                entityRowMapper.mapRow(ResultSetAdapter(rs))
            }
        )

        val changeType = if (persistedEntity!!.primaryKey != upsertEntity.primaryKey) ChangeType.UPDATE else ChangeType.CREATE
        insertHistory(persistedEntity, persistedEntity.version, changeType)

        return persistedEntity!!

    }


    fun setFields(updaters: List<FeatureToggleEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: FeatureToggleEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update toggles.feature_toggle set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("v_incremented", "v", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where feature_name = :featureName")
        sql.append(" and v = :v")

        sqlParams.addValue("featureName", updater.featureName.value)
        sqlParams.addValue("v", updater.version)
        sqlParams.addValue("v_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(FeatureToggleEntityMeta.TABLE_NAME, updater.primaryKey, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.featureName)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "contactPerson" -> sqlParams.addValue("contactPerson", (field.value as ContactPerson?)?.value)
            "description" -> sqlParams.addValue("description", (field.value as Description?)?.value)
            "enabled" -> sqlParams.addValue("enabled", field.value as Boolean)
            "infoLink" -> sqlParams.addValue("infoLink", (field.value as InfoLink?)?.value)
            "lastModifiedBy" -> sqlParams.addValue("lastModifiedBy", field.value as String)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "reviewDate" -> sqlParams.addValue("reviewDate", field.value as LocalDate?)
            "ticketKey" -> sqlParams.addValue("ticketKey", (field.value as TicketKey?)?.value)
        }

    }


    fun deleteByPrimaryKey(featureName: FeatureName): Boolean {

        val existingEntity = findByPrimaryKeyOrNull(featureName)

        if (existingEntity == null) {
            return false
        }

        val deletedCount = this.jdbcOps.update(
            "delete from toggles.feature_toggle where feature_name = :featureName",
            SqlParams().apply {
                addValue("featureName", featureName.value)
            }
        )

        if (deletedCount > 0) {

            this.historyDao.insert(history(existingEntity, existingEntity.version + 1, ChangeType.DELETE))
        }

        return deletedCount > 0

    }


    fun removeByPrimaryKey(featureName: FeatureName): FeatureToggleEntity? {

        val found = findByPrimaryKeyOrNull(featureName)

        if (found != null) {
            deleteByPrimaryKey(featureName)
        }

        return found

    }


}


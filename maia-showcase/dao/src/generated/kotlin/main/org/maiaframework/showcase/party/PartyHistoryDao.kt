// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.showcase.party

import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.SqlParams
import org.maiaframework.showcase.org.OrganizationHistoryEntity
import org.maiaframework.showcase.org.OrganizationHistoryEntityMeta
import org.maiaframework.showcase.person.PersonHistoryEntity
import org.maiaframework.showcase.person.PersonHistoryEntityMeta
import org.maiaframework.showcase.user.UserHistoryEntity
import org.maiaframework.showcase.user.UserHistoryEntityMeta
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository


@Repository
class PartyHistoryDao(
    private val fieldConverter: PartyHistoryEntityFieldConverter,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = PartyHistoryEntityRowMapper()


    private val primaryKeyRowMapper = PartyHistoryEntityPkRowMapper()


    fun insert(entity: PartyHistoryEntity) {

        when (entity) {
            is OrganizationHistoryEntity -> insertOrganizationHistoryEntity(entity)
            is UserHistoryEntity -> insertUserHistoryEntity(entity)
            is PersonHistoryEntity -> insertPersonHistoryEntity(entity)
        }

    }


    private fun insertOrganizationHistoryEntity(entity: OrganizationHistoryEntity) {

        jdbcOps.update(
            """
            insert into maia.v_party_history (
                type_discriminator,
                change_type,
                created_timestamp_utc,
                email_address,
                id,
                last_modified_timestamp_utc,
                lifecycle_state,
                org_name,
                version
            ) values (
                :typeDiscriminator,
                :changeType,
                :createdTimestampUtc,
                :emailAddress,
                :id,
                :lastModifiedTimestampUtc,
                :lifecycleState,
                :orgName,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", OrganizationHistoryEntityMeta.TYPE_DISCRIMINATOR)
                addValue("changeType", entity.changeType)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("displayName", entity.displayName)
                addValue("emailAddress", entity.emailAddress)
                addValue("id", entity.id)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("lifecycleState", entity.lifecycleState)
                addValue("orgName", entity.orgName)
                addValue("version", entity.version)
            }
        )

    }


    private fun insertUserHistoryEntity(entity: UserHistoryEntity) {

        jdbcOps.update(
            """
            insert into maia.v_party_history (
                type_discriminator,
                change_type,
                created_timestamp_utc,
                email_address,
                encrypted_password,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                some_strings,
                version
            ) values (
                :typeDiscriminator,
                :changeType,
                :createdTimestampUtc,
                :emailAddress,
                :encryptedPassword,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :someStrings,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", UserHistoryEntityMeta.TYPE_DISCRIMINATOR)
                addValue("changeType", entity.changeType)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("displayName", entity.displayName)
                addValue("emailAddress", entity.emailAddress)
                addValue("encryptedPassword", entity.encryptedPassword)
                addValue("firstName", entity.firstName)
                addValue("id", entity.id)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("lastName", entity.lastName)
                addValue("lifecycleState", entity.lifecycleState)
                addListOfStrings("someStrings", entity.someStrings)
                addValue("version", entity.version)
            }
        )

    }


    private fun insertPersonHistoryEntity(entity: PersonHistoryEntity) {

        jdbcOps.update(
            """
            insert into maia.v_party_history (
                type_discriminator,
                change_type,
                created_timestamp_utc,
                email_address,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                version
            ) values (
                :typeDiscriminator,
                :changeType,
                :createdTimestampUtc,
                :emailAddress,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("typeDiscriminator", PersonHistoryEntityMeta.TYPE_DISCRIMINATOR)
                addValue("changeType", entity.changeType)
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("displayName", entity.displayName)
                addValue("emailAddress", entity.emailAddress)
                addValue("firstName", entity.firstName)
                addValue("id", entity.id)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("lastName", entity.lastName)
                addValue("lifecycleState", entity.lifecycleState)
                addValue("version", entity.version)
            }
        )

    }


    fun bulkInsert(entities: List<PartyHistoryEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into maia.v_party_history (
                change_type,
                created_timestamp_utc,
                email_address,
                id,
                last_modified_timestamp_utc,
                lifecycle_state,
                version
            ) values (
                :changeType,
                :createdTimestampUtc,
                :emailAddress,
                :id,
                :lastModifiedTimestampUtc,
                :lifecycleState,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("changeType", entity.changeType)
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("displayName", entity.displayName)
                    addValue("emailAddress", entity.emailAddress)
                    addValue("id", entity.id)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("lifecycleState", entity.lifecycleState)
                    addValue("version", entity.version)
                }
            }
        )

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from maia.v_party_history",
            SqlParams()
        )

    }


    fun count(filter: PartyHistoryEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from maia.v_party_history
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(primaryKey: PartyHistoryEntityPk): PartyHistoryEntity {

        return findByPrimaryKeyOrNull(primaryKey)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    PartyHistoryEntity::class.java,
                    mapOf(
                        "id" to primaryKey.id,
                        "version" to primaryKey.version,
                    )
                ),
                PartyHistoryEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(primaryKey: PartyHistoryEntityPk): PartyHistoryEntity? {

        return jdbcOps.queryForList(
            "select * from maia.v_party_history where id = :id and version = :version",
            SqlParams().apply {
                addValue("id", primaryKey.id)
                addValue("version", primaryKey.version)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId, version: Long): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from maia.v_party_history where id = :id and version = :version",
            SqlParams().apply {
                addValue("id", id)
                addValue("version", version)
           }
        )
       
        return count > 0
       
    }

    fun findAllBy(filter: PartyHistoryEntityFilter): List<PartyHistoryEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from maia.v_party_history where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: PartyHistoryEntityFilter): Sequence<PartyHistoryEntityPk> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id, version from maia.v_party_history where $whereClause",
            sqlParams,
            this.primaryKeyRowMapper
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<PartyHistoryEntityPk> {

        return this.jdbcOps.queryForSequence(
            "select id, version from maia.v_party_history;",
            SqlParams(),
            this.primaryKeyRowMapper
        )

    }


    fun findAllBy(filter: PartyHistoryEntityFilter, pageable: Pageable): List<PartyHistoryEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from maia.v_party_history where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<PartyHistoryEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from maia.v_party_history;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


}


// This source was generated by the Maia Framework code generator
// Renderer class: class org.maiaframework.gen.renderers.JdbcDaoRenderer

package org.maiaframework.showcase.user

import org.maiaframework.domain.ChangeType
import org.maiaframework.domain.DomainId
import org.maiaframework.domain.EntityClassAndPk
import org.maiaframework.domain.LifecycleState
import org.maiaframework.domain.party.FirstName
import org.maiaframework.domain.party.LastName
import org.maiaframework.domain.persist.FieldUpdate
import org.maiaframework.jdbc.EntityNotFoundException
import org.maiaframework.jdbc.JdbcOps
import org.maiaframework.jdbc.MaiaRowMapper
import org.maiaframework.jdbc.OptimisticLockingException
import org.maiaframework.jdbc.SqlParams
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import java.time.Instant


@Repository
class UserDao(
    private val fieldConverter: UserEntityFieldConverter,
    private val historyDao: UserHistoryDao,
    private val jdbcOps: JdbcOps
) {


    private val entityRowMapper = UserEntityRowMapper()


    private val primaryKeyRowMapper = MaiaRowMapper { rsa -> rsa.readDomainId("id") }


    private val fetchForEditDtoRowMapper = UserFetchForEditDtoRowMapper()


    fun insert(entity: UserEntity) {

        jdbcOps.update(
            """
            insert into maia.v_party (
                type_discriminator,
                created_timestamp_utc,
                email_address,
                encrypted_password,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                some_strings,
                version
            ) values (
                'USR',
                :createdTimestampUtc,
                :emailAddress,
                :encryptedPassword,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :someStrings,
                :version
            )
            """.trimIndent(),
            SqlParams().apply {
                addValue("createdTimestampUtc", entity.createdTimestampUtc)
                addValue("displayName", entity.displayName)
                addValue("emailAddress", entity.emailAddress)
                addValue("encryptedPassword", entity.encryptedPassword)
                addValue("firstName", entity.firstName)
                addValue("id", entity.id)
                addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                addValue("lastName", entity.lastName)
                addValue("lifecycleState", entity.lifecycleState)
                addListOfStrings("someStrings", entity.someStrings)
                addValue("version", entity.version)
            }
        )

        insertHistory(entity, ChangeType.CREATE)

    }


    fun bulkInsert(entities: List<UserEntity>) {

        jdbcOps.batchUpdate(
            """
            insert into maia.v_party (
                type_discriminator,
                created_timestamp_utc,
                email_address,
                encrypted_password,
                first_name,
                id,
                last_modified_timestamp_utc,
                last_name,
                lifecycle_state,
                some_strings,
                version
            ) values (
                'USR',
                :createdTimestampUtc,
                :emailAddress,
                :encryptedPassword,
                :firstName,
                :id,
                :lastModifiedTimestampUtc,
                :lastName,
                :lifecycleState,
                :someStrings,
                :version
            )
            """.trimIndent(),
            entities.map { entity ->
                SqlParams().apply {
                    addValue("createdTimestampUtc", entity.createdTimestampUtc)
                    addValue("displayName", entity.displayName)
                    addValue("emailAddress", entity.emailAddress)
                    addValue("encryptedPassword", entity.encryptedPassword)
                    addValue("firstName", entity.firstName)
                    addValue("id", entity.id)
                    addValue("lastModifiedTimestampUtc", entity.lastModifiedTimestampUtc)
                    addValue("lastName", entity.lastName)
                    addValue("lifecycleState", entity.lifecycleState)
                    addListOfStrings("someStrings", entity.someStrings)
                    addValue("version", entity.version)
                }
            }
        )

        bulkInsertHistory(entities, ChangeType.CREATE)

    }


    private fun insertHistory(entity: UserEntity, changeType: ChangeType) {

        insertHistory(entity, entity.version, changeType)

    }


    private fun insertHistory(entity: UserEntity, version: Long, changeType: ChangeType) {

        this.historyDao.insert(history(entity, version, changeType))

    }


    private fun bulkInsertHistory(entities: List<UserEntity>, changeType: ChangeType) {

        val historyEntities = entities.map { history(it, it.version, changeType) }
        this.historyDao.bulkInsert(historyEntities)

    }


    private fun history(
        entity: UserEntity,
        version: Long,
        changeType: ChangeType
    ): UserHistoryEntity {

        val id = entity.id
        val createdTimestampUtc = entity.createdTimestampUtc
        val displayName = entity.displayName
        val emailAddress = entity.emailAddress
        val encryptedPassword = entity.encryptedPassword
        val firstName = entity.firstName
        val lastModifiedTimestampUtc = entity.lastModifiedTimestampUtc
        val lastName = entity.lastName
        val lifecycleState = entity.lifecycleState
        val someStrings = entity.someStrings

        return UserHistoryEntity(
                changeType,
                createdTimestampUtc,
                displayName,
                emailAddress,
                encryptedPassword,
                firstName,
                id,
                lastModifiedTimestampUtc,
                lastName,
                lifecycleState,
                someStrings,
                version)

    }


    fun count(): Long {

        return jdbcOps.queryForLong(
            "select count(*) from maia.v_party",
            SqlParams()
        )

    }


    fun count(filter: UserEntityFilter): Long {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return jdbcOps.queryForLong(
            """
            select count(*) from maia.v_party
            where $whereClause
            """.trimIndent(),
            sqlParams
        )

    }


    @Throws(EntityNotFoundException::class)
    fun findByPrimaryKey(id: DomainId): UserEntity {

        return findByPrimaryKeyOrNull(id)
            ?: throw EntityNotFoundException(
                EntityClassAndPk(
                    UserEntity::class.java,
                    mapOf(
                        "id" to id,
                    )
                ),
                UserEntityMeta.TABLE_NAME
            )

    }


    fun findByPrimaryKeyOrNull(id: DomainId): UserEntity? {

        return jdbcOps.queryForList(
            "select * from maia.v_party where id = :id",
            SqlParams().apply {
            addValue("id", id)
            },
            this.entityRowMapper
        ).firstOrNull()

    }


    fun existsByPrimaryKey(id: DomainId): Boolean {

        val count = jdbcOps.queryForInt(
            "select count(*) from maia.v_party where id = :id",
            SqlParams().apply {
                addValue("id", id)
           }
        )
       
        return count > 0
       
    }

    fun findAllBy(filter: UserEntityFilter): List<UserEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from maia.v_party where $whereClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    fun findPrimaryKeysAsSequence(filter: UserEntityFilter): Sequence<DomainId> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForSequence(
            "select id from maia.v_party where $whereClause",
            sqlParams,
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllPrimaryKeysAsSequence(): Sequence<DomainId> {

        return this.jdbcOps.queryForSequence(
            "select id from maia.v_party;",
            SqlParams(),
            { rsa -> rsa.readDomainId("id") }
        )

    }


    fun findAllBy(filter: UserEntityFilter, pageable: Pageable): List<UserEntity> {

        val whereClause = filter.whereClause(this.fieldConverter)
        val orderByClause = orderByClauseFor(pageable)
        val limitClause = limitClauseFor(pageable)
        val offsetClause = offsetClauseFor(pageable)

        val sqlParams = SqlParams()

        filter.populateSqlParams(sqlParams)

        return this.jdbcOps.queryForList(
            "select * from maia.v_party where $whereClause $orderByClause $limitClause $offsetClause",
            sqlParams,
            this.entityRowMapper
        )

    }


    private fun orderByClauseFor(pageable: Pageable): String {

        val properties = pageable.sort.map { "${it.property} ${it.direction}" }.joinToString(", ")
        return "ORDER BY $properties"

    }


    private fun limitClauseFor(pageable: Pageable): String {

        return "LIMIT ${pageable.pageSize}"

    }


    private fun offsetClauseFor(pageable: Pageable): String {

        return "OFFSET ${pageable.offset}"

    }


    fun findAllAsSequence(): Sequence<UserEntity> {

        return this.jdbcOps.queryForSequence(
            "select * from maia.v_party;",
            SqlParams(),
            this.entityRowMapper,
        )

    }


    fun fetchForEdit(id: DomainId): UserFetchForEditDto {

        return this.jdbcOps.queryForList(
            """
            select
                v_party.created_timestamp_utc as createdTimestampUtc,
                v_party.display_name as displayName,
                v_party.email_address as emailAddress,
                v_party.encrypted_password as encryptedPassword,
                v_party.first_name as firstName,
                v_party.id as id,
                v_party.last_modified_timestamp_utc as lastModifiedTimestampUtc,
                v_party.last_name as lastName,
                v_party.lifecycle_state as lifecycleState,
                v_party.some_strings as someStrings,
                v_party.version as version
            from maia.v_party
            where v_party.id = :id
            """,
            SqlParams().apply {
                addValue("id", id)
            },
            this.fetchForEditDtoRowMapper
        ).firstOrNull()
            ?: throw EntityNotFoundException(EntityClassAndPk(UserEntity::class.java, mapOf("id" to id)), UserEntityMeta.TABLE_NAME)

    }


    fun setFields(updaters: List<UserEntityUpdater>) {

        updaters.forEach { setFields(it) }

    }


    fun setFields(updater: UserEntityUpdater): Int {

        val sql = StringBuilder()
        val sqlParams = SqlParams()

        sql.append("update maia.v_party set ")

        val fieldClauses = updater.fields
            .plus(FieldUpdate("version_incremented", "version", updater.version + 1))
            .map { field ->

                addField(field, sqlParams)
                "${field.dbColumnName} = :${field.classFieldName}"

            }.joinToString(", ")

        sql.append(fieldClauses)
        sql.append(" where id = :id")
        sql.append(" and version = :version")

        sqlParams.addValue("id", updater.id)

        sqlParams.addValue("version", updater.version)
        sqlParams.addValue("version_incremented", updater.version + 1)

        val updateCount = this.jdbcOps.update(sql.toString(), sqlParams)

        if (updateCount == 0) {

            throw OptimisticLockingException(UserEntityMeta.TABLE_NAME, updater.primaryKeyMap, updater.version)

        } else {

            val updatedEntity = findByPrimaryKey(updater.id)
            insertHistory(updatedEntity, ChangeType.UPDATE)

        }

        return updateCount

    }


    private fun addField(field: FieldUpdate, sqlParams: SqlParams) {

        when (field.classFieldName) {
            "encryptedPassword" -> sqlParams.addValue("encryptedPassword", field.value as String)
            "firstName" -> sqlParams.addValue("firstName", field.value as FirstName?)
            "lastModifiedTimestampUtc" -> sqlParams.addValue("lastModifiedTimestampUtc", field.value as Instant)
            "lastName" -> sqlParams.addValue("lastName", field.value as LastName)
            "lifecycleState" -> sqlParams.addValue("lifecycleState", field.value as LifecycleState)
        }

    }


}

